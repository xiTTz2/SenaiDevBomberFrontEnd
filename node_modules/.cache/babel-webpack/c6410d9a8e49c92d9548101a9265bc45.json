{"ast":null,"code":"import _asyncToGenerator from \"/home/xittz/Documentos/sa-bombeiros3/sa-bombeiros/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport { parseByteRanges, parseContentRange, parseContentType } from './httputils';\nimport { BaseSource } from './basesource';\nimport { BlockedSource } from './blockedsource';\nimport { FetchClient } from './client/fetch';\nimport { XHRClient } from './client/xhr';\nimport { HttpClient } from './client/http';\n\nclass RemoteSource extends BaseSource {\n  /**\n   *\n   * @param {BaseClient} client\n   * @param {object} headers\n   * @param {numbers} maxRanges\n   * @param {boolean} allowFullFile\n   */\n  constructor(client, headers, maxRanges, allowFullFile) {\n    super();\n    this.client = client;\n    this.headers = headers;\n    this.maxRanges = maxRanges;\n    this.allowFullFile = allowFullFile;\n    this._fileSize = null;\n  }\n  /**\n   *\n   * @param {Slice[]} slices\n   */\n\n\n  fetch(slices, signal) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      // if we allow multi-ranges, split the incoming request into that many sub-requests\n      // and join them afterwards\n      if (_this.maxRanges >= slices.length) {\n        return _this.fetchSlices(slices, signal);\n      } else if (_this.maxRanges > 0 && slices.length > 1) {// TODO: split into multiple multi-range requests\n        // const subSlicesRequests = [];\n        // for (let i = 0; i < slices.length; i += this.maxRanges) {\n        //   subSlicesRequests.push(\n        //     this.fetchSlices(slices.slice(i, i + this.maxRanges), signal),\n        //   );\n        // }\n        // return (await Promise.all(subSlicesRequests)).flat();\n      } // otherwise make a single request for each slice\n\n\n      return Promise.all(slices.map(slice => _this.fetchSlice(slice, signal)));\n    })();\n  }\n\n  fetchSlices(slices, signal) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      const response = yield _this2.client.request({\n        headers: { ..._this2.headers,\n          Range: `bytes=${slices.map(({\n            offset,\n            length\n          }) => `${offset}-${offset + length}`).join(',')}`\n        },\n        signal\n      });\n\n      if (!response.ok) {\n        throw new Error('Error fetching data.');\n      } else if (response.status === 206) {\n        const {\n          type,\n          params\n        } = parseContentType(response.getHeader('content-type'));\n\n        if (type === 'multipart/byteranges') {\n          const byteRanges = parseByteRanges(yield response.getData(), params.boundary);\n          _this2._fileSize = byteRanges[0].fileSize || null;\n          return byteRanges;\n        }\n\n        const data = yield response.getData();\n        const {\n          start,\n          end,\n          total\n        } = parseContentRange(response.getHeader('content-range'));\n        _this2._fileSize = total || null;\n        const first = [{\n          data,\n          offset: start,\n          length: end - start\n        }];\n\n        if (slices.length > 1) {\n          // we requested more than one slice, but got only the first\n          // unfortunately, some HTTP Servers don't support multi-ranges\n          // and return onyl the first\n          // get the rest of the slices and fetch them iteratetively\n          const others = yield Promise.all(slices.slice(1).map(slice => _this2.fetchSlice(slice, signal)));\n          return first.concat(others);\n        }\n\n        return first;\n      } else {\n        if (!_this2.allowFullFile) {\n          throw new Error('Server responded with full file');\n        }\n\n        const data = yield response.getData();\n        _this2._fileSize = data.byteLength;\n        return [{\n          data,\n          offset: 0,\n          length: data.byteLength\n        }];\n      }\n    })();\n  }\n\n  fetchSlice(slice, signal) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        offset,\n        length\n      } = slice;\n      const response = yield _this3.client.request({\n        headers: { ..._this3.headers,\n          Range: `bytes=${offset}-${offset + length}`\n        },\n        signal\n      }); // check the response was okay and if the server actually understands range requests\n\n      if (!response.ok) {\n        throw new Error('Error fetching data.');\n      } else if (response.status === 206) {\n        const data = yield response.getData();\n        const {\n          total\n        } = parseContentRange(response.getHeader('content-range'));\n        _this3._fileSize = total || null;\n        return {\n          data,\n          offset,\n          length\n        };\n      } else {\n        if (!_this3.allowFullFile) {\n          throw new Error('Server responded with full file');\n        }\n\n        const data = yield response.getData();\n        _this3._fileSize = data.byteLength;\n        return {\n          data,\n          offset: 0,\n          length: data.byteLength\n        };\n      }\n    })();\n  }\n\n  get fileSize() {\n    return this._fileSize;\n  }\n\n}\n\nfunction maybeWrapInBlockedSource(source, {\n  blockSize,\n  cacheSize\n}) {\n  if (blockSize === null) {\n    return source;\n  }\n\n  return new BlockedSource(source, blockSize, cacheSize);\n}\n\nexport function makeFetchSource(url, {\n  headers = {},\n  credentials,\n  maxRanges = 0,\n  allowFullFile = false,\n  ...blockOptions\n} = {}) {\n  const client = new FetchClient(url, credentials);\n  const source = new RemoteSource(client, headers, maxRanges, allowFullFile);\n  return maybeWrapInBlockedSource(source, blockOptions);\n}\nexport function makeXHRSource(url, {\n  headers = {},\n  maxRanges = 0,\n  allowFullFile = false,\n  ...blockOptions\n} = {}) {\n  const client = new XHRClient(url);\n  const source = new RemoteSource(client, headers, maxRanges, allowFullFile);\n  return maybeWrapInBlockedSource(source, blockOptions);\n}\nexport function makeHttpSource(url, {\n  headers = {},\n  maxRanges = 0,\n  allowFullFile = false,\n  ...blockOptions\n} = {}) {\n  const client = new HttpClient(url);\n  const source = new RemoteSource(client, headers, maxRanges, allowFullFile);\n  return maybeWrapInBlockedSource(source, blockOptions);\n}\n/**\n *\n * @param {string} url\n * @param {object} options\n */\n\nexport function makeRemoteSource(url, {\n  forceXHR = false,\n  ...clientOptions\n} = {}) {\n  if (typeof fetch === 'function' && !forceXHR) {\n    return makeFetchSource(url, clientOptions);\n  }\n\n  if (typeof XMLHttpRequest !== 'undefined') {\n    return makeXHRSource(url, clientOptions);\n  }\n\n  return makeHttpSource(url, clientOptions);\n}","map":{"version":3,"sources":["/home/xittz/Documentos/sa-bombeiros3/sa-bombeiros/node_modules/geotiff/src/source/remote.js"],"names":["parseByteRanges","parseContentRange","parseContentType","BaseSource","BlockedSource","FetchClient","XHRClient","HttpClient","RemoteSource","constructor","client","headers","maxRanges","allowFullFile","_fileSize","fetch","slices","signal","length","fetchSlices","Promise","all","map","slice","fetchSlice","response","request","Range","offset","join","ok","Error","status","type","params","getHeader","byteRanges","getData","boundary","fileSize","data","start","end","total","first","others","concat","byteLength","maybeWrapInBlockedSource","source","blockSize","cacheSize","makeFetchSource","url","credentials","blockOptions","makeXHRSource","makeHttpSource","makeRemoteSource","forceXHR","clientOptions","XMLHttpRequest"],"mappings":"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","sourcesContent":["import { parseByteRanges, parseContentRange, parseContentType } from './httputils';\nimport { BaseSource } from './basesource';\nimport { BlockedSource } from './blockedsource';\n\nimport { FetchClient } from './client/fetch';\nimport { XHRClient } from './client/xhr';\nimport { HttpClient } from './client/http';\n\nclass RemoteSource extends BaseSource {\n  /**\n   *\n   * @param {BaseClient} client\n   * @param {object} headers\n   * @param {numbers} maxRanges\n   * @param {boolean} allowFullFile\n   */\n  constructor(client, headers, maxRanges, allowFullFile) {\n    super();\n    this.client = client;\n    this.headers = headers;\n    this.maxRanges = maxRanges;\n    this.allowFullFile = allowFullFile;\n    this._fileSize = null;\n  }\n\n  /**\n   *\n   * @param {Slice[]} slices\n   */\n  async fetch(slices, signal) {\n    // if we allow multi-ranges, split the incoming request into that many sub-requests\n    // and join them afterwards\n    if (this.maxRanges >= slices.length) {\n      return this.fetchSlices(slices, signal);\n    } else if (this.maxRanges > 0 && slices.length > 1) {\n      // TODO: split into multiple multi-range requests\n\n      // const subSlicesRequests = [];\n      // for (let i = 0; i < slices.length; i += this.maxRanges) {\n      //   subSlicesRequests.push(\n      //     this.fetchSlices(slices.slice(i, i + this.maxRanges), signal),\n      //   );\n      // }\n      // return (await Promise.all(subSlicesRequests)).flat();\n    }\n\n    // otherwise make a single request for each slice\n    return Promise.all(\n      slices.map((slice) => this.fetchSlice(slice, signal)),\n    );\n  }\n\n  async fetchSlices(slices, signal) {\n    const response = await this.client.request({\n      headers: {\n        ...this.headers,\n        Range: `bytes=${slices\n          .map(({ offset, length }) => `${offset}-${offset + length}`)\n          .join(',')\n        }`,\n      },\n      signal,\n    });\n\n    if (!response.ok) {\n      throw new Error('Error fetching data.');\n    } else if (response.status === 206) {\n      const { type, params } = parseContentType(response.getHeader('content-type'));\n      if (type === 'multipart/byteranges') {\n        const byteRanges = parseByteRanges(await response.getData(), params.boundary);\n        this._fileSize = byteRanges[0].fileSize || null;\n        return byteRanges;\n      }\n\n      const data = await response.getData();\n\n      const { start, end, total } = parseContentRange(response.getHeader('content-range'));\n      this._fileSize = total || null;\n      const first = [{\n        data,\n        offset: start,\n        length: end - start,\n      }];\n\n      if (slices.length > 1) {\n        // we requested more than one slice, but got only the first\n        // unfortunately, some HTTP Servers don't support multi-ranges\n        // and return onyl the first\n\n        // get the rest of the slices and fetch them iteratetively\n        const others = await Promise.all(slices.slice(1).map((slice) => this.fetchSlice(slice, signal)));\n        return first.concat(others);\n      }\n      return first;\n    } else {\n      if (!this.allowFullFile) {\n        throw new Error('Server responded with full file');\n      }\n      const data = await response.getData();\n      this._fileSize = data.byteLength;\n      return [{\n        data,\n        offset: 0,\n        length: data.byteLength,\n      }];\n    }\n  }\n\n  async fetchSlice(slice, signal) {\n    const { offset, length } = slice;\n    const response = await this.client.request({\n      headers: {\n        ...this.headers,\n        Range: `bytes=${offset}-${offset + length}`,\n      },\n      signal,\n    });\n\n    // check the response was okay and if the server actually understands range requests\n    if (!response.ok) {\n      throw new Error('Error fetching data.');\n    } else if (response.status === 206) {\n      const data = await response.getData();\n\n      const { total } = parseContentRange(response.getHeader('content-range'));\n      this._fileSize = total || null;\n      return {\n        data,\n        offset,\n        length,\n      };\n    } else {\n      if (!this.allowFullFile) {\n        throw new Error('Server responded with full file');\n      }\n\n      const data = await response.getData();\n\n      this._fileSize = data.byteLength;\n      return {\n        data,\n        offset: 0,\n        length: data.byteLength,\n      };\n    }\n  }\n\n  get fileSize() {\n    return this._fileSize;\n  }\n}\n\nfunction maybeWrapInBlockedSource(source, { blockSize, cacheSize }) {\n  if (blockSize === null) {\n    return source;\n  }\n  return new BlockedSource(source, blockSize, cacheSize);\n}\n\nexport function makeFetchSource(url, { headers = {}, credentials, maxRanges = 0, allowFullFile = false, ...blockOptions } = {}) {\n  const client = new FetchClient(url, credentials);\n  const source = new RemoteSource(client, headers, maxRanges, allowFullFile);\n  return maybeWrapInBlockedSource(source, blockOptions);\n}\n\nexport function makeXHRSource(url, { headers = {}, maxRanges = 0, allowFullFile = false, ...blockOptions } = {}) {\n  const client = new XHRClient(url);\n  const source = new RemoteSource(client, headers, maxRanges, allowFullFile);\n  return maybeWrapInBlockedSource(source, blockOptions);\n}\n\nexport function makeHttpSource(url, { headers = {}, maxRanges = 0, allowFullFile = false, ...blockOptions } = {}) {\n  const client = new HttpClient(url);\n  const source = new RemoteSource(client, headers, maxRanges, allowFullFile);\n  return maybeWrapInBlockedSource(source, blockOptions);\n}\n\n/**\n *\n * @param {string} url\n * @param {object} options\n */\nexport function makeRemoteSource(url, { forceXHR = false, ...clientOptions } = {}) {\n  if (typeof fetch === 'function' && !forceXHR) {\n    return makeFetchSource(url, clientOptions);\n  }\n  if (typeof XMLHttpRequest !== 'undefined') {\n    return makeXHRSource(url, clientOptions);\n  }\n  return makeHttpSource(url, clientOptions);\n}\n"]},"metadata":{},"sourceType":"module"}