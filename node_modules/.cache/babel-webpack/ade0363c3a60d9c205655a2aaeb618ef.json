{"ast":null,"code":"import _asyncToGenerator from \"/home/xittz/Documentos/sa-bombeiros3/sa-bombeiros/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport GeoTIFFImage from './geotiffimage';\nimport DataView64 from './dataview64';\nimport DataSlice from './dataslice';\nimport Pool from './pool';\nimport { makeRemoteSource } from './source/remote';\nimport { makeBufferSource } from './source/arraybuffer';\nimport { makeFileReaderSource } from './source/filereader';\nimport { makeFileSource } from './source/file';\nimport { fieldTypes, fieldTagNames, arrayFields, geoKeyNames } from './globals';\nimport { writeGeotiff } from './geotiffwriter';\nimport * as globals from './globals';\nimport * as rgb from './rgb';\nimport { getDecoder, addDecoder } from './compression';\nimport { setLogger } from './logging';\nexport { globals };\nexport { rgb };\nexport { getDecoder, addDecoder };\nexport { setLogger };\n\nfunction getFieldTypeLength(fieldType) {\n  switch (fieldType) {\n    case fieldTypes.BYTE:\n    case fieldTypes.ASCII:\n    case fieldTypes.SBYTE:\n    case fieldTypes.UNDEFINED:\n      return 1;\n\n    case fieldTypes.SHORT:\n    case fieldTypes.SSHORT:\n      return 2;\n\n    case fieldTypes.LONG:\n    case fieldTypes.SLONG:\n    case fieldTypes.FLOAT:\n    case fieldTypes.IFD:\n      return 4;\n\n    case fieldTypes.RATIONAL:\n    case fieldTypes.SRATIONAL:\n    case fieldTypes.DOUBLE:\n    case fieldTypes.LONG8:\n    case fieldTypes.SLONG8:\n    case fieldTypes.IFD8:\n      return 8;\n\n    default:\n      throw new RangeError(`Invalid field type: ${fieldType}`);\n  }\n}\n\nfunction parseGeoKeyDirectory(fileDirectory) {\n  const rawGeoKeyDirectory = fileDirectory.GeoKeyDirectory;\n\n  if (!rawGeoKeyDirectory) {\n    return null;\n  }\n\n  const geoKeyDirectory = {};\n\n  for (let i = 4; i <= rawGeoKeyDirectory[3] * 4; i += 4) {\n    const key = geoKeyNames[rawGeoKeyDirectory[i]];\n    const location = rawGeoKeyDirectory[i + 1] ? fieldTagNames[rawGeoKeyDirectory[i + 1]] : null;\n    const count = rawGeoKeyDirectory[i + 2];\n    const offset = rawGeoKeyDirectory[i + 3];\n    let value = null;\n\n    if (!location) {\n      value = offset;\n    } else {\n      value = fileDirectory[location];\n\n      if (typeof value === 'undefined' || value === null) {\n        throw new Error(`Could not get value of geoKey '${key}'.`);\n      } else if (typeof value === 'string') {\n        value = value.substring(offset, offset + count - 1);\n      } else if (value.subarray) {\n        value = value.subarray(offset, offset + count);\n\n        if (count === 1) {\n          value = value[0];\n        }\n      }\n    }\n\n    geoKeyDirectory[key] = value;\n  }\n\n  return geoKeyDirectory;\n}\n\nfunction getValues(dataSlice, fieldType, count, offset) {\n  let values = null;\n  let readMethod = null;\n  const fieldTypeLength = getFieldTypeLength(fieldType);\n\n  switch (fieldType) {\n    case fieldTypes.BYTE:\n    case fieldTypes.ASCII:\n    case fieldTypes.UNDEFINED:\n      values = new Uint8Array(count);\n      readMethod = dataSlice.readUint8;\n      break;\n\n    case fieldTypes.SBYTE:\n      values = new Int8Array(count);\n      readMethod = dataSlice.readInt8;\n      break;\n\n    case fieldTypes.SHORT:\n      values = new Uint16Array(count);\n      readMethod = dataSlice.readUint16;\n      break;\n\n    case fieldTypes.SSHORT:\n      values = new Int16Array(count);\n      readMethod = dataSlice.readInt16;\n      break;\n\n    case fieldTypes.LONG:\n    case fieldTypes.IFD:\n      values = new Uint32Array(count);\n      readMethod = dataSlice.readUint32;\n      break;\n\n    case fieldTypes.SLONG:\n      values = new Int32Array(count);\n      readMethod = dataSlice.readInt32;\n      break;\n\n    case fieldTypes.LONG8:\n    case fieldTypes.IFD8:\n      values = new Array(count);\n      readMethod = dataSlice.readUint64;\n      break;\n\n    case fieldTypes.SLONG8:\n      values = new Array(count);\n      readMethod = dataSlice.readInt64;\n      break;\n\n    case fieldTypes.RATIONAL:\n      values = new Uint32Array(count * 2);\n      readMethod = dataSlice.readUint32;\n      break;\n\n    case fieldTypes.SRATIONAL:\n      values = new Int32Array(count * 2);\n      readMethod = dataSlice.readInt32;\n      break;\n\n    case fieldTypes.FLOAT:\n      values = new Float32Array(count);\n      readMethod = dataSlice.readFloat32;\n      break;\n\n    case fieldTypes.DOUBLE:\n      values = new Float64Array(count);\n      readMethod = dataSlice.readFloat64;\n      break;\n\n    default:\n      throw new RangeError(`Invalid field type: ${fieldType}`);\n  } // normal fields\n\n\n  if (!(fieldType === fieldTypes.RATIONAL || fieldType === fieldTypes.SRATIONAL)) {\n    for (let i = 0; i < count; ++i) {\n      values[i] = readMethod.call(dataSlice, offset + i * fieldTypeLength);\n    }\n  } else {\n    // RATIONAL or SRATIONAL\n    for (let i = 0; i < count; i += 2) {\n      values[i] = readMethod.call(dataSlice, offset + i * fieldTypeLength);\n      values[i + 1] = readMethod.call(dataSlice, offset + (i * fieldTypeLength + 4));\n    }\n  }\n\n  if (fieldType === fieldTypes.ASCII) {\n    return new TextDecoder('utf-8').decode(values);\n  }\n\n  return values;\n}\n/**\n * Data class to store the parsed file directory, geo key directory and\n * offset to the next IFD\n */\n\n\nclass ImageFileDirectory {\n  constructor(fileDirectory, geoKeyDirectory, nextIFDByteOffset) {\n    this.fileDirectory = fileDirectory;\n    this.geoKeyDirectory = geoKeyDirectory;\n    this.nextIFDByteOffset = nextIFDByteOffset;\n  }\n\n}\n/**\n * Error class for cases when an IFD index was requested, that does not exist\n * in the file.\n */\n\n\nclass GeoTIFFImageIndexError extends Error {\n  constructor(index) {\n    super(`No image at index ${index}`);\n    this.index = index;\n  }\n\n}\n\nclass GeoTIFFBase {\n  /**\n   * (experimental) Reads raster data from the best fitting image. This function uses\n   * the image with the lowest resolution that is still a higher resolution than the\n   * requested resolution.\n   * When specified, the `bbox` option is translated to the `window` option and the\n   * `resX` and `resY` to `width` and `height` respectively.\n   * Then, the [readRasters]{@link GeoTIFFImage#readRasters} method of the selected\n   * image is called and the result returned.\n   * @see GeoTIFFImage.readRasters\n   * @param {Object} [options={}] optional parameters\n   * @param {Array} [options.window=whole image] the subset to read data from.\n   * @param {Array} [options.bbox=whole image] the subset to read data from in\n   *                                           geographical coordinates.\n   * @param {Array} [options.samples=all samples] the selection of samples to read from.\n   * @param {Boolean} [options.interleave=false] whether the data shall be read\n   *                                             in one single array or separate\n   *                                             arrays.\n   * @param {Number} [options.pool=null] The optional decoder pool to use.\n   * @param {Number} [options.width] The desired width of the output. When the width is not the\n   *                                 same as the images, resampling will be performed.\n   * @param {Number} [options.height] The desired height of the output. When the width is not the\n   *                                  same as the images, resampling will be performed.\n   * @param {String} [options.resampleMethod='nearest'] The desired resampling method.\n   * @param {AbortSignal} [options.signal] An AbortSignal that may be signalled if the request is\n   *                                       to be aborted\n   * @param {Number|Number[]} [options.fillValue] The value to use for parts of the image\n   *                                              outside of the images extent. When multiple\n   *                                              samples are requested, an array of fill values\n   *                                              can be passed.\n   * @returns {Promise.<(TypedArray|TypedArray[])>} the decoded arrays as a promise\n   */\n  readRasters(options = {}) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        window: imageWindow,\n        width,\n        height\n      } = options;\n      let {\n        resX,\n        resY,\n        bbox\n      } = options;\n      const firstImage = yield _this.getImage();\n      let usedImage = firstImage;\n      const imageCount = yield _this.getImageCount();\n      const imgBBox = firstImage.getBoundingBox();\n\n      if (imageWindow && bbox) {\n        throw new Error('Both \"bbox\" and \"window\" passed.');\n      } // if width/height is passed, transform it to resolution\n\n\n      if (width || height) {\n        // if we have an image window (pixel coordinates), transform it to a BBox\n        // using the origin/resolution of the first image.\n        if (imageWindow) {\n          const [oX, oY] = firstImage.getOrigin();\n          const [rX, rY] = firstImage.getResolution();\n          bbox = [oX + imageWindow[0] * rX, oY + imageWindow[1] * rY, oX + imageWindow[2] * rX, oY + imageWindow[3] * rY];\n        } // if we have a bbox (or calculated one)\n\n\n        const usedBBox = bbox || imgBBox;\n\n        if (width) {\n          if (resX) {\n            throw new Error('Both width and resX passed');\n          }\n\n          resX = (usedBBox[2] - usedBBox[0]) / width;\n        }\n\n        if (height) {\n          if (resY) {\n            throw new Error('Both width and resY passed');\n          }\n\n          resY = (usedBBox[3] - usedBBox[1]) / height;\n        }\n      } // if resolution is set or calculated, try to get the image with the worst acceptable resolution\n\n\n      if (resX || resY) {\n        const allImages = [];\n\n        for (let i = 0; i < imageCount; ++i) {\n          const image = yield _this.getImage(i);\n          const {\n            SubfileType: subfileType,\n            NewSubfileType: newSubfileType\n          } = image.fileDirectory;\n\n          if (i === 0 || subfileType === 2 || newSubfileType & 1) {\n            allImages.push(image);\n          }\n        }\n\n        allImages.sort((a, b) => a.getWidth() - b.getWidth());\n\n        for (let i = 0; i < allImages.length; ++i) {\n          const image = allImages[i];\n          const imgResX = (imgBBox[2] - imgBBox[0]) / image.getWidth();\n          const imgResY = (imgBBox[3] - imgBBox[1]) / image.getHeight();\n          usedImage = image;\n\n          if (resX && resX > imgResX || resY && resY > imgResY) {\n            break;\n          }\n        }\n      }\n\n      let wnd = imageWindow;\n\n      if (bbox) {\n        const [oX, oY] = firstImage.getOrigin();\n        const [imageResX, imageResY] = usedImage.getResolution(firstImage);\n        wnd = [Math.round((bbox[0] - oX) / imageResX), Math.round((bbox[1] - oY) / imageResY), Math.round((bbox[2] - oX) / imageResX), Math.round((bbox[3] - oY) / imageResY)];\n        wnd = [Math.min(wnd[0], wnd[2]), Math.min(wnd[1], wnd[3]), Math.max(wnd[0], wnd[2]), Math.max(wnd[1], wnd[3])];\n      }\n\n      return usedImage.readRasters({ ...options,\n        window: wnd\n      });\n    })();\n  }\n\n}\n/**\n * The abstraction for a whole GeoTIFF file.\n * @augments GeoTIFFBase\n */\n\n\nclass GeoTIFF extends GeoTIFFBase {\n  /**\n   * @constructor\n   * @param {Source} source The datasource to read from.\n   * @param {Boolean} littleEndian Whether the image uses little endian.\n   * @param {Boolean} bigTiff Whether the image uses bigTIFF conventions.\n   * @param {Number} firstIFDOffset The numeric byte-offset from the start of the image\n   *                                to the first IFD.\n   * @param {Object} [options] further options.\n   * @param {Boolean} [options.cache=false] whether or not decoded tiles shall be cached.\n   */\n  constructor(source, littleEndian, bigTiff, firstIFDOffset, options = {}) {\n    super();\n    this.source = source;\n    this.littleEndian = littleEndian;\n    this.bigTiff = bigTiff;\n    this.firstIFDOffset = firstIFDOffset;\n    this.cache = options.cache || false;\n    this.ifdRequests = [];\n    this.ghostValues = null;\n  }\n\n  getSlice(offset, size) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      const fallbackSize = _this2.bigTiff ? 4048 : 1024;\n      return new DataSlice((yield _this2.source.fetch([{\n        offset,\n        length: typeof size !== 'undefined' ? size : fallbackSize\n      }]))[0], offset, _this2.littleEndian, _this2.bigTiff);\n    })();\n  }\n  /**\n   * Instructs to parse an image file directory at the given file offset.\n   * As there is no way to ensure that a location is indeed the start of an IFD,\n   * this function must be called with caution (e.g only using the IFD offsets from\n   * the headers or other IFDs).\n   * @param {number} offset the offset to parse the IFD at\n   * @returns {ImageFileDirectory} the parsed IFD\n   */\n\n\n  parseFileDirectoryAt(offset) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      const entrySize = _this3.bigTiff ? 20 : 12;\n      const offsetSize = _this3.bigTiff ? 8 : 2;\n      let dataSlice = yield _this3.getSlice(offset);\n      const numDirEntries = _this3.bigTiff ? dataSlice.readUint64(offset) : dataSlice.readUint16(offset); // if the slice does not cover the whole IFD, request a bigger slice, where the\n      // whole IFD fits: num of entries + n x tag length + offset to next IFD\n\n      const byteSize = numDirEntries * entrySize + (_this3.bigTiff ? 16 : 6);\n\n      if (!dataSlice.covers(offset, byteSize)) {\n        dataSlice = yield _this3.getSlice(offset, byteSize);\n      }\n\n      const fileDirectory = {}; // loop over the IFD and create a file directory object\n\n      let i = offset + (_this3.bigTiff ? 8 : 2);\n\n      for (let entryCount = 0; entryCount < numDirEntries; i += entrySize, ++entryCount) {\n        const fieldTag = dataSlice.readUint16(i);\n        const fieldType = dataSlice.readUint16(i + 2);\n        const typeCount = _this3.bigTiff ? dataSlice.readUint64(i + 4) : dataSlice.readUint32(i + 4);\n        let fieldValues;\n        let value;\n        const fieldTypeLength = getFieldTypeLength(fieldType);\n        const valueOffset = i + (_this3.bigTiff ? 12 : 8); // check whether the value is directly encoded in the tag or refers to a\n        // different external byte range\n\n        if (fieldTypeLength * typeCount <= (_this3.bigTiff ? 8 : 4)) {\n          fieldValues = getValues(dataSlice, fieldType, typeCount, valueOffset);\n        } else {\n          // resolve the reference to the actual byte range\n          const actualOffset = dataSlice.readOffset(valueOffset);\n          const length = getFieldTypeLength(fieldType) * typeCount; // check, whether we actually cover the referenced byte range; if not,\n          // request a new slice of bytes to read from it\n\n          if (dataSlice.covers(actualOffset, length)) {\n            fieldValues = getValues(dataSlice, fieldType, typeCount, actualOffset);\n          } else {\n            const fieldDataSlice = yield _this3.getSlice(actualOffset, length);\n            fieldValues = getValues(fieldDataSlice, fieldType, typeCount, actualOffset);\n          }\n        } // unpack single values from the array\n\n\n        if (typeCount === 1 && arrayFields.indexOf(fieldTag) === -1 && !(fieldType === fieldTypes.RATIONAL || fieldType === fieldTypes.SRATIONAL)) {\n          value = fieldValues[0];\n        } else {\n          value = fieldValues;\n        } // write the tags value to the file directly\n\n\n        fileDirectory[fieldTagNames[fieldTag]] = value;\n      }\n\n      const geoKeyDirectory = parseGeoKeyDirectory(fileDirectory);\n      const nextIFDByteOffset = dataSlice.readOffset(offset + offsetSize + entrySize * numDirEntries);\n      return new ImageFileDirectory(fileDirectory, geoKeyDirectory, nextIFDByteOffset);\n    })();\n  }\n\n  requestIFD(index) {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      // see if we already have that IFD index requested.\n      if (_this4.ifdRequests[index]) {\n        // attach to an already requested IFD\n        return _this4.ifdRequests[index];\n      } else if (index === 0) {\n        // special case for index 0\n        _this4.ifdRequests[index] = _this4.parseFileDirectoryAt(_this4.firstIFDOffset);\n        return _this4.ifdRequests[index];\n      } else if (!_this4.ifdRequests[index - 1]) {\n        // if the previous IFD was not yet loaded, load that one first\n        // this is the recursive call.\n        try {\n          _this4.ifdRequests[index - 1] = _this4.requestIFD(index - 1);\n        } catch (e) {\n          // if the previous one already was an index error, rethrow\n          // with the current index\n          if (e instanceof GeoTIFFImageIndexError) {\n            throw new GeoTIFFImageIndexError(index);\n          } // rethrow anything else\n\n\n          throw e;\n        }\n      } // if the previous IFD was loaded, we can finally fetch the one we are interested in.\n      // we need to wrap this in an IIFE, otherwise this.ifdRequests[index] would be delayed\n\n\n      _this4.ifdRequests[index] = _asyncToGenerator(function* () {\n        const previousIfd = yield _this4.ifdRequests[index - 1];\n\n        if (previousIfd.nextIFDByteOffset === 0) {\n          throw new GeoTIFFImageIndexError(index);\n        }\n\n        return _this4.parseFileDirectoryAt(previousIfd.nextIFDByteOffset);\n      })();\n      return _this4.ifdRequests[index];\n    })();\n  }\n  /**\n   * Get the n-th internal subfile of an image. By default, the first is returned.\n   *\n   * @param {Number} [index=0] the index of the image to return.\n   * @returns {GeoTIFFImage} the image at the given index\n   */\n\n\n  getImage(index = 0) {\n    var _this5 = this;\n\n    return _asyncToGenerator(function* () {\n      const ifd = yield _this5.requestIFD(index);\n      return new GeoTIFFImage(ifd.fileDirectory, ifd.geoKeyDirectory, _this5.dataView, _this5.littleEndian, _this5.cache, _this5.source);\n    })();\n  }\n  /**\n   * Returns the count of the internal subfiles.\n   *\n   * @returns {Number} the number of internal subfile images\n   */\n\n\n  getImageCount() {\n    var _this6 = this;\n\n    return _asyncToGenerator(function* () {\n      let index = 0; // loop until we run out of IFDs\n\n      let hasNext = true;\n\n      while (hasNext) {\n        try {\n          yield _this6.requestIFD(index);\n          ++index;\n        } catch (e) {\n          if (e instanceof GeoTIFFImageIndexError) {\n            hasNext = false;\n          } else {\n            throw e;\n          }\n        }\n      }\n\n      return index;\n    })();\n  }\n  /**\n   * Get the values of the COG ghost area as a parsed map.\n   * See https://gdal.org/drivers/raster/cog.html#header-ghost-area for reference\n   * @returns {Object} the parsed ghost area or null, if no such area was found\n   */\n\n\n  getGhostValues() {\n    var _this7 = this;\n\n    return _asyncToGenerator(function* () {\n      const offset = _this7.bigTiff ? 16 : 8;\n\n      if (_this7.ghostValues) {\n        return _this7.ghostValues;\n      }\n\n      const detectionString = 'GDAL_STRUCTURAL_METADATA_SIZE=';\n      const heuristicAreaSize = detectionString.length + 100;\n      let slice = yield _this7.getSlice(offset, heuristicAreaSize);\n\n      if (detectionString === getValues(slice, fieldTypes.ASCII, detectionString.length, offset)) {\n        const valuesString = getValues(slice, fieldTypes.ASCII, heuristicAreaSize, offset);\n        const firstLine = valuesString.split('\\n')[0];\n        const metadataSize = Number(firstLine.split('=')[1].split(' ')[0]) + firstLine.length;\n\n        if (metadataSize > heuristicAreaSize) {\n          slice = yield _this7.getSlice(offset, metadataSize);\n        }\n\n        const fullString = getValues(slice, fieldTypes.ASCII, metadataSize, offset);\n        _this7.ghostValues = {};\n        fullString.split('\\n').filter(line => line.length > 0).map(line => line.split('=')).forEach(([key, value]) => {\n          _this7.ghostValues[key] = value;\n        });\n      }\n\n      return _this7.ghostValues;\n    })();\n  }\n  /**\n   * Parse a (Geo)TIFF file from the given source.\n   *\n   * @param {source~Source} source The source of data to parse from.\n   * @param {object} options Additional options.\n   * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n   *                               to be aborted\n   */\n\n\n  static fromSource(source, options, signal) {\n    return _asyncToGenerator(function* () {\n      const headerData = (yield source.fetch([{\n        offset: 0,\n        length: 1024\n      }], signal))[0];\n      const dataView = new DataView64(headerData);\n      const BOM = dataView.getUint16(0, 0);\n      let littleEndian;\n\n      if (BOM === 0x4949) {\n        littleEndian = true;\n      } else if (BOM === 0x4D4D) {\n        littleEndian = false;\n      } else {\n        throw new TypeError('Invalid byte order value.');\n      }\n\n      const magicNumber = dataView.getUint16(2, littleEndian);\n      let bigTiff;\n\n      if (magicNumber === 42) {\n        bigTiff = false;\n      } else if (magicNumber === 43) {\n        bigTiff = true;\n        const offsetByteSize = dataView.getUint16(4, littleEndian);\n\n        if (offsetByteSize !== 8) {\n          throw new Error('Unsupported offset byte-size.');\n        }\n      } else {\n        throw new TypeError('Invalid magic number.');\n      }\n\n      const firstIFDOffset = bigTiff ? dataView.getUint64(8, littleEndian) : dataView.getUint32(4, littleEndian);\n      return new GeoTIFF(source, littleEndian, bigTiff, firstIFDOffset, options);\n    })();\n  }\n  /**\n   * Closes the underlying file buffer\n   * N.B. After the GeoTIFF has been completely processed it needs\n   * to be closed but only if it has been constructed from a file.\n   */\n\n\n  close() {\n    if (typeof this.source.close === 'function') {\n      return this.source.close();\n    }\n\n    return false;\n  }\n\n}\n\nexport { GeoTIFF };\nexport default GeoTIFF;\n/**\n * Wrapper for GeoTIFF files that have external overviews.\n * @augments GeoTIFFBase\n */\n\nclass MultiGeoTIFF extends GeoTIFFBase {\n  /**\n   * Construct a new MultiGeoTIFF from a main and several overview files.\n   * @param {GeoTIFF} mainFile The main GeoTIFF file.\n   * @param {GeoTIFF[]} overviewFiles An array of overview files.\n   */\n  constructor(mainFile, overviewFiles) {\n    super();\n    this.mainFile = mainFile;\n    this.overviewFiles = overviewFiles;\n    this.imageFiles = [mainFile].concat(overviewFiles);\n    this.fileDirectoriesPerFile = null;\n    this.fileDirectoriesPerFileParsing = null;\n    this.imageCount = null;\n  }\n\n  parseFileDirectoriesPerFile() {\n    var _this8 = this;\n\n    return _asyncToGenerator(function* () {\n      const requests = [_this8.mainFile.parseFileDirectoryAt(_this8.mainFile.firstIFDOffset)].concat(_this8.overviewFiles.map(file => file.parseFileDirectoryAt(file.firstIFDOffset)));\n      _this8.fileDirectoriesPerFile = yield Promise.all(requests);\n      return _this8.fileDirectoriesPerFile;\n    })();\n  }\n  /**\n   * Get the n-th internal subfile of an image. By default, the first is returned.\n   *\n   * @param {Number} [index=0] the index of the image to return.\n   * @returns {GeoTIFFImage} the image at the given index\n   */\n\n\n  getImage(index = 0) {\n    var _this9 = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this9.getImageCount();\n      yield _this9.parseFileDirectoriesPerFile();\n      let visited = 0;\n      let relativeIndex = 0;\n\n      for (let i = 0; i < _this9.imageFiles.length; i++) {\n        const imageFile = _this9.imageFiles[i];\n\n        for (let ii = 0; ii < _this9.imageCounts[i]; ii++) {\n          if (index === visited) {\n            const ifd = yield imageFile.requestIFD(relativeIndex);\n            return new GeoTIFFImage(ifd.fileDirectory, ifd.geoKeyDirectory, imageFile.dataView, imageFile.littleEndian, imageFile.cache, imageFile.source);\n          }\n\n          visited++;\n          relativeIndex++;\n        }\n\n        relativeIndex = 0;\n      }\n\n      throw new RangeError('Invalid image index');\n    })();\n  }\n  /**\n   * Returns the count of the internal subfiles.\n   *\n   * @returns {Number} the number of internal subfile images\n   */\n\n\n  getImageCount() {\n    var _this10 = this;\n\n    return _asyncToGenerator(function* () {\n      if (_this10.imageCount !== null) {\n        return _this10.imageCount;\n      }\n\n      const requests = [_this10.mainFile.getImageCount()].concat(_this10.overviewFiles.map(file => file.getImageCount()));\n      _this10.imageCounts = yield Promise.all(requests);\n      _this10.imageCount = _this10.imageCounts.reduce((count, ifds) => count + ifds, 0);\n      return _this10.imageCount;\n    })();\n  }\n\n}\n\nexport { MultiGeoTIFF };\n/**\n * Creates a new GeoTIFF from a remote URL.\n * @param {string} url The URL to access the image from\n * @param {object} [options] Additional options to pass to the source.\n *                           See {@link makeRemoteSource} for details.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise.<GeoTIFF>} The resulting GeoTIFF file.\n */\n\nexport function fromUrl(_x) {\n  return _fromUrl.apply(this, arguments);\n}\n/**\n * Construct a new GeoTIFF from an\n * [ArrayBuffer]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer}.\n * @param {ArrayBuffer} arrayBuffer The data to read the file from.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise.<GeoTIFF>} The resulting GeoTIFF file.\n */\n\nfunction _fromUrl() {\n  _fromUrl = _asyncToGenerator(function* (url, options = {}, signal) {\n    return GeoTIFF.fromSource(makeRemoteSource(url, options), signal);\n  });\n  return _fromUrl.apply(this, arguments);\n}\n\nexport function fromArrayBuffer(_x2, _x3) {\n  return _fromArrayBuffer.apply(this, arguments);\n}\n/**\n * Construct a GeoTIFF from a local file path. This uses the node\n * [filesystem API]{@link https://nodejs.org/api/fs.html} and is\n * not available on browsers.\n *\n * N.B. After the GeoTIFF has been completely processed it needs\n * to be closed but only if it has been constructed from a file.\n * @param {string} path The file path to read from.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise.<GeoTIFF>} The resulting GeoTIFF file.\n */\n\nfunction _fromArrayBuffer() {\n  _fromArrayBuffer = _asyncToGenerator(function* (arrayBuffer, signal) {\n    return GeoTIFF.fromSource(makeBufferSource(arrayBuffer), signal);\n  });\n  return _fromArrayBuffer.apply(this, arguments);\n}\n\nexport function fromFile(_x4, _x5) {\n  return _fromFile.apply(this, arguments);\n}\n/**\n * Construct a GeoTIFF from an HTML\n * [Blob]{@link https://developer.mozilla.org/en-US/docs/Web/API/Blob} or\n * [File]{@link https://developer.mozilla.org/en-US/docs/Web/API/File}\n * object.\n * @param {Blob|File} blob The Blob or File object to read from.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise.<GeoTIFF>} The resulting GeoTIFF file.\n */\n\nfunction _fromFile() {\n  _fromFile = _asyncToGenerator(function* (path, signal) {\n    return GeoTIFF.fromSource(makeFileSource(path), signal);\n  });\n  return _fromFile.apply(this, arguments);\n}\n\nexport function fromBlob(_x6, _x7) {\n  return _fromBlob.apply(this, arguments);\n}\n/**\n * Construct a MultiGeoTIFF from the given URLs.\n * @param {string} mainUrl The URL for the main file.\n * @param {string[]} overviewUrls An array of URLs for the overview images.\n * @param {object} [options] Additional options to pass to the source.\n *                           See [makeRemoteSource]{@link module:source.makeRemoteSource}\n *                           for details.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise.<MultiGeoTIFF>} The resulting MultiGeoTIFF file.\n */\n\nfunction _fromBlob() {\n  _fromBlob = _asyncToGenerator(function* (blob, signal) {\n    return GeoTIFF.fromSource(makeFileReaderSource(blob), signal);\n  });\n  return _fromBlob.apply(this, arguments);\n}\n\nexport function fromUrls(_x8) {\n  return _fromUrls.apply(this, arguments);\n}\n/**\n * Main creating function for GeoTIFF files.\n * @param {(Array)} array of pixel values\n * @returns {metadata} metadata\n */\n\nfunction _fromUrls() {\n  _fromUrls = _asyncToGenerator(function* (mainUrl, overviewUrls = [], options = {}, signal) {\n    const mainFile = yield GeoTIFF.fromSource(makeRemoteSource(mainUrl, options), signal);\n    const overviewFiles = yield Promise.all(overviewUrls.map(url => GeoTIFF.fromSource(makeRemoteSource(url, options))));\n    return new MultiGeoTIFF(mainFile, overviewFiles);\n  });\n  return _fromUrls.apply(this, arguments);\n}\n\nexport function writeArrayBuffer(_x9, _x10) {\n  return _writeArrayBuffer.apply(this, arguments);\n}\n\nfunction _writeArrayBuffer() {\n  _writeArrayBuffer = _asyncToGenerator(function* (values, metadata) {\n    return writeGeotiff(values, metadata);\n  });\n  return _writeArrayBuffer.apply(this, arguments);\n}\n\nexport { Pool };","map":{"version":3,"sources":["/home/xittz/Documentos/sa-bombeiros3/sa-bombeiros/node_modules/geotiff/src/geotiff.js"],"names":["GeoTIFFImage","DataView64","DataSlice","Pool","makeRemoteSource","makeBufferSource","makeFileReaderSource","makeFileSource","fieldTypes","fieldTagNames","arrayFields","geoKeyNames","writeGeotiff","globals","rgb","getDecoder","addDecoder","setLogger","getFieldTypeLength","fieldType","BYTE","ASCII","SBYTE","UNDEFINED","SHORT","SSHORT","LONG","SLONG","FLOAT","IFD","RATIONAL","SRATIONAL","DOUBLE","LONG8","SLONG8","IFD8","RangeError","parseGeoKeyDirectory","fileDirectory","rawGeoKeyDirectory","GeoKeyDirectory","geoKeyDirectory","i","key","location","count","offset","value","Error","substring","subarray","getValues","dataSlice","values","readMethod","fieldTypeLength","Uint8Array","readUint8","Int8Array","readInt8","Uint16Array","readUint16","Int16Array","readInt16","Uint32Array","readUint32","Int32Array","readInt32","Array","readUint64","readInt64","Float32Array","readFloat32","Float64Array","readFloat64","call","TextDecoder","decode","ImageFileDirectory","constructor","nextIFDByteOffset","GeoTIFFImageIndexError","index","GeoTIFFBase","readRasters","options","window","imageWindow","width","height","resX","resY","bbox","firstImage","getImage","usedImage","imageCount","getImageCount","imgBBox","getBoundingBox","oX","oY","getOrigin","rX","rY","getResolution","usedBBox","allImages","image","SubfileType","subfileType","NewSubfileType","newSubfileType","push","sort","a","b","getWidth","length","imgResX","imgResY","getHeight","wnd","imageResX","imageResY","Math","round","min","max","GeoTIFF","source","littleEndian","bigTiff","firstIFDOffset","cache","ifdRequests","ghostValues","getSlice","size","fallbackSize","fetch","parseFileDirectoryAt","entrySize","offsetSize","numDirEntries","byteSize","covers","entryCount","fieldTag","typeCount","fieldValues","valueOffset","actualOffset","readOffset","fieldDataSlice","indexOf","requestIFD","e","previousIfd","ifd","dataView","hasNext","getGhostValues","detectionString","heuristicAreaSize","slice","valuesString","firstLine","split","metadataSize","Number","fullString","filter","line","map","forEach","fromSource","signal","headerData","BOM","getUint16","TypeError","magicNumber","offsetByteSize","getUint64","getUint32","close","MultiGeoTIFF","mainFile","overviewFiles","imageFiles","concat","fileDirectoriesPerFile","fileDirectoriesPerFileParsing","parseFileDirectoriesPerFile","requests","file","Promise","all","visited","relativeIndex","imageFile","ii","imageCounts","reduce","ifds","fromUrl","url","fromArrayBuffer","arrayBuffer","fromFile","path","fromBlob","blob","fromUrls","mainUrl","overviewUrls","writeArrayBuffer","metadata"],"mappings":";AAAA,OAAOA,YAAP,MAAyB,gBAAzB;AACA,OAAOC,UAAP,MAAuB,cAAvB;AACA,OAAOC,SAAP,MAAsB,aAAtB;AACA,OAAOC,IAAP,MAAiB,QAAjB;AAEA,SAASC,gBAAT,QAAiC,iBAAjC;AACA,SAASC,gBAAT,QAAiC,sBAAjC;AACA,SAASC,oBAAT,QAAqC,qBAArC;AACA,SAASC,cAAT,QAA+B,eAA/B;AAEA,SAASC,UAAT,EAAqBC,aAArB,EAAoCC,WAApC,EAAiDC,WAAjD,QAAoE,WAApE;AACA,SAASC,YAAT,QAA6B,iBAA7B;AACA,OAAO,KAAKC,OAAZ,MAAyB,WAAzB;AACA,OAAO,KAAKC,GAAZ,MAAqB,OAArB;AACA,SAASC,UAAT,EAAqBC,UAArB,QAAuC,eAAvC;AACA,SAASC,SAAT,QAA0B,WAA1B;AAEA,SAASJ,OAAT;AACA,SAASC,GAAT;AACA,SAASC,UAAT,EAAqBC,UAArB;AACA,SAASC,SAAT;;AAEA,SAASC,kBAAT,CAA4BC,SAA5B,EAAuC;AACrC,UAAQA,SAAR;AACE,SAAKX,UAAU,CAACY,IAAhB;AAAsB,SAAKZ,UAAU,CAACa,KAAhB;AAAuB,SAAKb,UAAU,CAACc,KAAhB;AAAuB,SAAKd,UAAU,CAACe,SAAhB;AAClE,aAAO,CAAP;;AACF,SAAKf,UAAU,CAACgB,KAAhB;AAAuB,SAAKhB,UAAU,CAACiB,MAAhB;AACrB,aAAO,CAAP;;AACF,SAAKjB,UAAU,CAACkB,IAAhB;AAAsB,SAAKlB,UAAU,CAACmB,KAAhB;AAAuB,SAAKnB,UAAU,CAACoB,KAAhB;AAAuB,SAAKpB,UAAU,CAACqB,GAAhB;AAClE,aAAO,CAAP;;AACF,SAAKrB,UAAU,CAACsB,QAAhB;AAA0B,SAAKtB,UAAU,CAACuB,SAAhB;AAA2B,SAAKvB,UAAU,CAACwB,MAAhB;AACrD,SAAKxB,UAAU,CAACyB,KAAhB;AAAuB,SAAKzB,UAAU,CAAC0B,MAAhB;AAAwB,SAAK1B,UAAU,CAAC2B,IAAhB;AAC7C,aAAO,CAAP;;AACF;AACE,YAAM,IAAIC,UAAJ,CAAgB,uBAAsBjB,SAAU,EAAhD,CAAN;AAXJ;AAaD;;AAED,SAASkB,oBAAT,CAA8BC,aAA9B,EAA6C;AAC3C,QAAMC,kBAAkB,GAAGD,aAAa,CAACE,eAAzC;;AACA,MAAI,CAACD,kBAAL,EAAyB;AACvB,WAAO,IAAP;AACD;;AAED,QAAME,eAAe,GAAG,EAAxB;;AACA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,IAAIH,kBAAkB,CAAC,CAAD,CAAlB,GAAwB,CAA7C,EAAgDG,CAAC,IAAI,CAArD,EAAwD;AACtD,UAAMC,GAAG,GAAGhC,WAAW,CAAC4B,kBAAkB,CAACG,CAAD,CAAnB,CAAvB;AACA,UAAME,QAAQ,GAAIL,kBAAkB,CAACG,CAAC,GAAG,CAAL,CAAnB,GACZjC,aAAa,CAAC8B,kBAAkB,CAACG,CAAC,GAAG,CAAL,CAAnB,CADD,GACgC,IADjD;AAEA,UAAMG,KAAK,GAAGN,kBAAkB,CAACG,CAAC,GAAG,CAAL,CAAhC;AACA,UAAMI,MAAM,GAAGP,kBAAkB,CAACG,CAAC,GAAG,CAAL,CAAjC;AAEA,QAAIK,KAAK,GAAG,IAAZ;;AACA,QAAI,CAACH,QAAL,EAAe;AACbG,MAAAA,KAAK,GAAGD,MAAR;AACD,KAFD,MAEO;AACLC,MAAAA,KAAK,GAAGT,aAAa,CAACM,QAAD,CAArB;;AACA,UAAI,OAAOG,KAAP,KAAiB,WAAjB,IAAgCA,KAAK,KAAK,IAA9C,EAAoD;AAClD,cAAM,IAAIC,KAAJ,CAAW,kCAAiCL,GAAI,IAAhD,CAAN;AACD,OAFD,MAEO,IAAI,OAAOI,KAAP,KAAiB,QAArB,EAA+B;AACpCA,QAAAA,KAAK,GAAGA,KAAK,CAACE,SAAN,CAAgBH,MAAhB,EAAwBA,MAAM,GAAGD,KAAT,GAAiB,CAAzC,CAAR;AACD,OAFM,MAEA,IAAIE,KAAK,CAACG,QAAV,EAAoB;AACzBH,QAAAA,KAAK,GAAGA,KAAK,CAACG,QAAN,CAAeJ,MAAf,EAAuBA,MAAM,GAAGD,KAAhC,CAAR;;AACA,YAAIA,KAAK,KAAK,CAAd,EAAiB;AACfE,UAAAA,KAAK,GAAGA,KAAK,CAAC,CAAD,CAAb;AACD;AACF;AACF;;AACDN,IAAAA,eAAe,CAACE,GAAD,CAAf,GAAuBI,KAAvB;AACD;;AACD,SAAON,eAAP;AACD;;AAED,SAASU,SAAT,CAAmBC,SAAnB,EAA8BjC,SAA9B,EAAyC0B,KAAzC,EAAgDC,MAAhD,EAAwD;AACtD,MAAIO,MAAM,GAAG,IAAb;AACA,MAAIC,UAAU,GAAG,IAAjB;AACA,QAAMC,eAAe,GAAGrC,kBAAkB,CAACC,SAAD,CAA1C;;AAEA,UAAQA,SAAR;AACE,SAAKX,UAAU,CAACY,IAAhB;AAAsB,SAAKZ,UAAU,CAACa,KAAhB;AAAuB,SAAKb,UAAU,CAACe,SAAhB;AAC3C8B,MAAAA,MAAM,GAAG,IAAIG,UAAJ,CAAeX,KAAf,CAAT;AAAgCS,MAAAA,UAAU,GAAGF,SAAS,CAACK,SAAvB;AAChC;;AACF,SAAKjD,UAAU,CAACc,KAAhB;AACE+B,MAAAA,MAAM,GAAG,IAAIK,SAAJ,CAAcb,KAAd,CAAT;AAA+BS,MAAAA,UAAU,GAAGF,SAAS,CAACO,QAAvB;AAC/B;;AACF,SAAKnD,UAAU,CAACgB,KAAhB;AACE6B,MAAAA,MAAM,GAAG,IAAIO,WAAJ,CAAgBf,KAAhB,CAAT;AAAiCS,MAAAA,UAAU,GAAGF,SAAS,CAACS,UAAvB;AACjC;;AACF,SAAKrD,UAAU,CAACiB,MAAhB;AACE4B,MAAAA,MAAM,GAAG,IAAIS,UAAJ,CAAejB,KAAf,CAAT;AAAgCS,MAAAA,UAAU,GAAGF,SAAS,CAACW,SAAvB;AAChC;;AACF,SAAKvD,UAAU,CAACkB,IAAhB;AAAsB,SAAKlB,UAAU,CAACqB,GAAhB;AACpBwB,MAAAA,MAAM,GAAG,IAAIW,WAAJ,CAAgBnB,KAAhB,CAAT;AAAiCS,MAAAA,UAAU,GAAGF,SAAS,CAACa,UAAvB;AACjC;;AACF,SAAKzD,UAAU,CAACmB,KAAhB;AACE0B,MAAAA,MAAM,GAAG,IAAIa,UAAJ,CAAerB,KAAf,CAAT;AAAgCS,MAAAA,UAAU,GAAGF,SAAS,CAACe,SAAvB;AAChC;;AACF,SAAK3D,UAAU,CAACyB,KAAhB;AAAuB,SAAKzB,UAAU,CAAC2B,IAAhB;AACrBkB,MAAAA,MAAM,GAAG,IAAIe,KAAJ,CAAUvB,KAAV,CAAT;AAA2BS,MAAAA,UAAU,GAAGF,SAAS,CAACiB,UAAvB;AAC3B;;AACF,SAAK7D,UAAU,CAAC0B,MAAhB;AACEmB,MAAAA,MAAM,GAAG,IAAIe,KAAJ,CAAUvB,KAAV,CAAT;AAA2BS,MAAAA,UAAU,GAAGF,SAAS,CAACkB,SAAvB;AAC3B;;AACF,SAAK9D,UAAU,CAACsB,QAAhB;AACEuB,MAAAA,MAAM,GAAG,IAAIW,WAAJ,CAAgBnB,KAAK,GAAG,CAAxB,CAAT;AAAqCS,MAAAA,UAAU,GAAGF,SAAS,CAACa,UAAvB;AACrC;;AACF,SAAKzD,UAAU,CAACuB,SAAhB;AACEsB,MAAAA,MAAM,GAAG,IAAIa,UAAJ,CAAerB,KAAK,GAAG,CAAvB,CAAT;AAAoCS,MAAAA,UAAU,GAAGF,SAAS,CAACe,SAAvB;AACpC;;AACF,SAAK3D,UAAU,CAACoB,KAAhB;AACEyB,MAAAA,MAAM,GAAG,IAAIkB,YAAJ,CAAiB1B,KAAjB,CAAT;AAAkCS,MAAAA,UAAU,GAAGF,SAAS,CAACoB,WAAvB;AAClC;;AACF,SAAKhE,UAAU,CAACwB,MAAhB;AACEqB,MAAAA,MAAM,GAAG,IAAIoB,YAAJ,CAAiB5B,KAAjB,CAAT;AAAkCS,MAAAA,UAAU,GAAGF,SAAS,CAACsB,WAAvB;AAClC;;AACF;AACE,YAAM,IAAItC,UAAJ,CAAgB,uBAAsBjB,SAAU,EAAhD,CAAN;AAtCJ,GALsD,CA8CtD;;;AACA,MAAI,EAAEA,SAAS,KAAKX,UAAU,CAACsB,QAAzB,IAAqCX,SAAS,KAAKX,UAAU,CAACuB,SAAhE,CAAJ,EAAgF;AAC9E,SAAK,IAAIW,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGG,KAApB,EAA2B,EAAEH,CAA7B,EAAgC;AAC9BW,MAAAA,MAAM,CAACX,CAAD,CAAN,GAAYY,UAAU,CAACqB,IAAX,CACVvB,SADU,EACCN,MAAM,GAAIJ,CAAC,GAAGa,eADf,CAAZ;AAGD;AACF,GAND,MAMO;AAAE;AACP,SAAK,IAAIb,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGG,KAApB,EAA2BH,CAAC,IAAI,CAAhC,EAAmC;AACjCW,MAAAA,MAAM,CAACX,CAAD,CAAN,GAAYY,UAAU,CAACqB,IAAX,CACVvB,SADU,EACCN,MAAM,GAAIJ,CAAC,GAAGa,eADf,CAAZ;AAGAF,MAAAA,MAAM,CAACX,CAAC,GAAG,CAAL,CAAN,GAAgBY,UAAU,CAACqB,IAAX,CACdvB,SADc,EACHN,MAAM,IAAKJ,CAAC,GAAGa,eAAL,GAAwB,CAA5B,CADH,CAAhB;AAGD;AACF;;AAED,MAAIpC,SAAS,KAAKX,UAAU,CAACa,KAA7B,EAAoC;AAClC,WAAO,IAAIuD,WAAJ,CAAgB,OAAhB,EAAyBC,MAAzB,CAAgCxB,MAAhC,CAAP;AACD;;AACD,SAAOA,MAAP;AACD;AAED;AACA;AACA;AACA;;;AACA,MAAMyB,kBAAN,CAAyB;AACvBC,EAAAA,WAAW,CAACzC,aAAD,EAAgBG,eAAhB,EAAiCuC,iBAAjC,EAAoD;AAC7D,SAAK1C,aAAL,GAAqBA,aAArB;AACA,SAAKG,eAAL,GAAuBA,eAAvB;AACA,SAAKuC,iBAAL,GAAyBA,iBAAzB;AACD;;AALsB;AAQzB;AACA;AACA;AACA;;;AACA,MAAMC,sBAAN,SAAqCjC,KAArC,CAA2C;AACzC+B,EAAAA,WAAW,CAACG,KAAD,EAAQ;AACjB,UAAO,qBAAoBA,KAAM,EAAjC;AACA,SAAKA,KAAL,GAAaA,KAAb;AACD;;AAJwC;;AAO3C,MAAMC,WAAN,CAAkB;AAChB;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACQC,EAAAA,WAAW,CAACC,OAAO,GAAG,EAAX,EAAe;AAAA;;AAAA;AAC9B,YAAM;AAAEC,QAAAA,MAAM,EAAEC,WAAV;AAAuBC,QAAAA,KAAvB;AAA8BC,QAAAA;AAA9B,UAAyCJ,OAA/C;AACA,UAAI;AAAEK,QAAAA,IAAF;AAAQC,QAAAA,IAAR;AAAcC,QAAAA;AAAd,UAAuBP,OAA3B;AAEA,YAAMQ,UAAU,SAAS,KAAI,CAACC,QAAL,EAAzB;AACA,UAAIC,SAAS,GAAGF,UAAhB;AACA,YAAMG,UAAU,SAAS,KAAI,CAACC,aAAL,EAAzB;AACA,YAAMC,OAAO,GAAGL,UAAU,CAACM,cAAX,EAAhB;;AAEA,UAAIZ,WAAW,IAAIK,IAAnB,EAAyB;AACvB,cAAM,IAAI5C,KAAJ,CAAU,kCAAV,CAAN;AACD,OAX6B,CAa9B;;;AACA,UAAIwC,KAAK,IAAIC,MAAb,EAAqB;AACnB;AACA;AACA,YAAIF,WAAJ,EAAiB;AACf,gBAAM,CAACa,EAAD,EAAKC,EAAL,IAAWR,UAAU,CAACS,SAAX,EAAjB;AACA,gBAAM,CAACC,EAAD,EAAKC,EAAL,IAAWX,UAAU,CAACY,aAAX,EAAjB;AAEAb,UAAAA,IAAI,GAAG,CACLQ,EAAE,GAAIb,WAAW,CAAC,CAAD,CAAX,GAAiBgB,EADlB,EAELF,EAAE,GAAId,WAAW,CAAC,CAAD,CAAX,GAAiBiB,EAFlB,EAGLJ,EAAE,GAAIb,WAAW,CAAC,CAAD,CAAX,GAAiBgB,EAHlB,EAILF,EAAE,GAAId,WAAW,CAAC,CAAD,CAAX,GAAiBiB,EAJlB,CAAP;AAMD,SAbkB,CAenB;;;AAEA,cAAME,QAAQ,GAAGd,IAAI,IAAIM,OAAzB;;AAEA,YAAIV,KAAJ,EAAW;AACT,cAAIE,IAAJ,EAAU;AACR,kBAAM,IAAI1C,KAAJ,CAAU,4BAAV,CAAN;AACD;;AACD0C,UAAAA,IAAI,GAAG,CAACgB,QAAQ,CAAC,CAAD,CAAR,GAAcA,QAAQ,CAAC,CAAD,CAAvB,IAA8BlB,KAArC;AACD;;AACD,YAAIC,MAAJ,EAAY;AACV,cAAIE,IAAJ,EAAU;AACR,kBAAM,IAAI3C,KAAJ,CAAU,4BAAV,CAAN;AACD;;AACD2C,UAAAA,IAAI,GAAG,CAACe,QAAQ,CAAC,CAAD,CAAR,GAAcA,QAAQ,CAAC,CAAD,CAAvB,IAA8BjB,MAArC;AACD;AACF,OA7C6B,CA+C9B;;;AACA,UAAIC,IAAI,IAAIC,IAAZ,EAAkB;AAChB,cAAMgB,SAAS,GAAG,EAAlB;;AACA,aAAK,IAAIjE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGsD,UAApB,EAAgC,EAAEtD,CAAlC,EAAqC;AACnC,gBAAMkE,KAAK,SAAS,KAAI,CAACd,QAAL,CAAcpD,CAAd,CAApB;AACA,gBAAM;AAAEmE,YAAAA,WAAW,EAAEC,WAAf;AAA4BC,YAAAA,cAAc,EAAEC;AAA5C,cAA+DJ,KAAK,CAACtE,aAA3E;;AACA,cAAII,CAAC,KAAK,CAAN,IAAWoE,WAAW,KAAK,CAA3B,IAAgCE,cAAc,GAAG,CAArD,EAAwD;AACtDL,YAAAA,SAAS,CAACM,IAAV,CAAeL,KAAf;AACD;AACF;;AAEDD,QAAAA,SAAS,CAACO,IAAV,CAAe,CAACC,CAAD,EAAIC,CAAJ,KAAUD,CAAC,CAACE,QAAF,KAAeD,CAAC,CAACC,QAAF,EAAxC;;AACA,aAAK,IAAI3E,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGiE,SAAS,CAACW,MAA9B,EAAsC,EAAE5E,CAAxC,EAA2C;AACzC,gBAAMkE,KAAK,GAAGD,SAAS,CAACjE,CAAD,CAAvB;AACA,gBAAM6E,OAAO,GAAG,CAACrB,OAAO,CAAC,CAAD,CAAP,GAAaA,OAAO,CAAC,CAAD,CAArB,IAA4BU,KAAK,CAACS,QAAN,EAA5C;AACA,gBAAMG,OAAO,GAAG,CAACtB,OAAO,CAAC,CAAD,CAAP,GAAaA,OAAO,CAAC,CAAD,CAArB,IAA4BU,KAAK,CAACa,SAAN,EAA5C;AAEA1B,UAAAA,SAAS,GAAGa,KAAZ;;AACA,cAAKlB,IAAI,IAAIA,IAAI,GAAG6B,OAAhB,IAA6B5B,IAAI,IAAIA,IAAI,GAAG6B,OAAhD,EAA0D;AACxD;AACD;AACF;AACF;;AAED,UAAIE,GAAG,GAAGnC,WAAV;;AACA,UAAIK,IAAJ,EAAU;AACR,cAAM,CAACQ,EAAD,EAAKC,EAAL,IAAWR,UAAU,CAACS,SAAX,EAAjB;AACA,cAAM,CAACqB,SAAD,EAAYC,SAAZ,IAAyB7B,SAAS,CAACU,aAAV,CAAwBZ,UAAxB,CAA/B;AAEA6B,QAAAA,GAAG,GAAG,CACJG,IAAI,CAACC,KAAL,CAAW,CAAClC,IAAI,CAAC,CAAD,CAAJ,GAAUQ,EAAX,IAAiBuB,SAA5B,CADI,EAEJE,IAAI,CAACC,KAAL,CAAW,CAAClC,IAAI,CAAC,CAAD,CAAJ,GAAUS,EAAX,IAAiBuB,SAA5B,CAFI,EAGJC,IAAI,CAACC,KAAL,CAAW,CAAClC,IAAI,CAAC,CAAD,CAAJ,GAAUQ,EAAX,IAAiBuB,SAA5B,CAHI,EAIJE,IAAI,CAACC,KAAL,CAAW,CAAClC,IAAI,CAAC,CAAD,CAAJ,GAAUS,EAAX,IAAiBuB,SAA5B,CAJI,CAAN;AAMAF,QAAAA,GAAG,GAAG,CACJG,IAAI,CAACE,GAAL,CAASL,GAAG,CAAC,CAAD,CAAZ,EAAiBA,GAAG,CAAC,CAAD,CAApB,CADI,EAEJG,IAAI,CAACE,GAAL,CAASL,GAAG,CAAC,CAAD,CAAZ,EAAiBA,GAAG,CAAC,CAAD,CAApB,CAFI,EAGJG,IAAI,CAACG,GAAL,CAASN,GAAG,CAAC,CAAD,CAAZ,EAAiBA,GAAG,CAAC,CAAD,CAApB,CAHI,EAIJG,IAAI,CAACG,GAAL,CAASN,GAAG,CAAC,CAAD,CAAZ,EAAiBA,GAAG,CAAC,CAAD,CAApB,CAJI,CAAN;AAMD;;AAED,aAAO3B,SAAS,CAACX,WAAV,CAAsB,EAAE,GAAGC,OAAL;AAAcC,QAAAA,MAAM,EAAEoC;AAAtB,OAAtB,CAAP;AA1F8B;AA2F/B;;AA3He;AA8HlB;AACA;AACA;AACA;;;AACA,MAAMO,OAAN,SAAsB9C,WAAtB,CAAkC;AAChC;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACEJ,EAAAA,WAAW,CAACmD,MAAD,EAASC,YAAT,EAAuBC,OAAvB,EAAgCC,cAAhC,EAAgDhD,OAAO,GAAG,EAA1D,EAA8D;AACvE;AACA,SAAK6C,MAAL,GAAcA,MAAd;AACA,SAAKC,YAAL,GAAoBA,YAApB;AACA,SAAKC,OAAL,GAAeA,OAAf;AACA,SAAKC,cAAL,GAAsBA,cAAtB;AACA,SAAKC,KAAL,GAAajD,OAAO,CAACiD,KAAR,IAAiB,KAA9B;AACA,SAAKC,WAAL,GAAmB,EAAnB;AACA,SAAKC,WAAL,GAAmB,IAAnB;AACD;;AAEKC,EAAAA,QAAQ,CAAC3F,MAAD,EAAS4F,IAAT,EAAe;AAAA;;AAAA;AAC3B,YAAMC,YAAY,GAAG,MAAI,CAACP,OAAL,GAAe,IAAf,GAAsB,IAA3C;AACA,aAAO,IAAIlI,SAAJ,CACL,OAAO,MAAI,CAACgI,MAAL,CAAYU,KAAZ,CAAkB,CAAC;AACxB9F,QAAAA,MADwB;AAExBwE,QAAAA,MAAM,EAAE,OAAOoB,IAAP,KAAgB,WAAhB,GAA8BA,IAA9B,GAAqCC;AAFrB,OAAD,CAAlB,CAAP,EAGK,CAHL,CADK,EAKL7F,MALK,EAML,MAAI,CAACqF,YANA,EAOL,MAAI,CAACC,OAPA,CAAP;AAF2B;AAW5B;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;AACQS,EAAAA,oBAAoB,CAAC/F,MAAD,EAAS;AAAA;;AAAA;AACjC,YAAMgG,SAAS,GAAG,MAAI,CAACV,OAAL,GAAe,EAAf,GAAoB,EAAtC;AACA,YAAMW,UAAU,GAAG,MAAI,CAACX,OAAL,GAAe,CAAf,GAAmB,CAAtC;AAEA,UAAIhF,SAAS,SAAS,MAAI,CAACqF,QAAL,CAAc3F,MAAd,CAAtB;AACA,YAAMkG,aAAa,GAAG,MAAI,CAACZ,OAAL,GAClBhF,SAAS,CAACiB,UAAV,CAAqBvB,MAArB,CADkB,GAElBM,SAAS,CAACS,UAAV,CAAqBf,MAArB,CAFJ,CALiC,CASjC;AACA;;AACA,YAAMmG,QAAQ,GAAID,aAAa,GAAGF,SAAjB,IAA+B,MAAI,CAACV,OAAL,GAAe,EAAf,GAAoB,CAAnD,CAAjB;;AACA,UAAI,CAAChF,SAAS,CAAC8F,MAAV,CAAiBpG,MAAjB,EAAyBmG,QAAzB,CAAL,EAAyC;AACvC7F,QAAAA,SAAS,SAAS,MAAI,CAACqF,QAAL,CAAc3F,MAAd,EAAsBmG,QAAtB,CAAlB;AACD;;AAED,YAAM3G,aAAa,GAAG,EAAtB,CAhBiC,CAkBjC;;AACA,UAAII,CAAC,GAAGI,MAAM,IAAI,MAAI,CAACsF,OAAL,GAAe,CAAf,GAAmB,CAAvB,CAAd;;AACA,WAAK,IAAIe,UAAU,GAAG,CAAtB,EAAyBA,UAAU,GAAGH,aAAtC,EAAqDtG,CAAC,IAAIoG,SAAL,EAAgB,EAAEK,UAAvE,EAAmF;AACjF,cAAMC,QAAQ,GAAGhG,SAAS,CAACS,UAAV,CAAqBnB,CAArB,CAAjB;AACA,cAAMvB,SAAS,GAAGiC,SAAS,CAACS,UAAV,CAAqBnB,CAAC,GAAG,CAAzB,CAAlB;AACA,cAAM2G,SAAS,GAAG,MAAI,CAACjB,OAAL,GACdhF,SAAS,CAACiB,UAAV,CAAqB3B,CAAC,GAAG,CAAzB,CADc,GAEdU,SAAS,CAACa,UAAV,CAAqBvB,CAAC,GAAG,CAAzB,CAFJ;AAIA,YAAI4G,WAAJ;AACA,YAAIvG,KAAJ;AACA,cAAMQ,eAAe,GAAGrC,kBAAkB,CAACC,SAAD,CAA1C;AACA,cAAMoI,WAAW,GAAG7G,CAAC,IAAI,MAAI,CAAC0F,OAAL,GAAe,EAAf,GAAoB,CAAxB,CAArB,CAViF,CAYjF;AACA;;AACA,YAAI7E,eAAe,GAAG8F,SAAlB,KAAgC,MAAI,CAACjB,OAAL,GAAe,CAAf,GAAmB,CAAnD,CAAJ,EAA2D;AACzDkB,UAAAA,WAAW,GAAGnG,SAAS,CAACC,SAAD,EAAYjC,SAAZ,EAAuBkI,SAAvB,EAAkCE,WAAlC,CAAvB;AACD,SAFD,MAEO;AACL;AACA,gBAAMC,YAAY,GAAGpG,SAAS,CAACqG,UAAV,CAAqBF,WAArB,CAArB;AACA,gBAAMjC,MAAM,GAAGpG,kBAAkB,CAACC,SAAD,CAAlB,GAAgCkI,SAA/C,CAHK,CAKL;AACA;;AACA,cAAIjG,SAAS,CAAC8F,MAAV,CAAiBM,YAAjB,EAA+BlC,MAA/B,CAAJ,EAA4C;AAC1CgC,YAAAA,WAAW,GAAGnG,SAAS,CAACC,SAAD,EAAYjC,SAAZ,EAAuBkI,SAAvB,EAAkCG,YAAlC,CAAvB;AACD,WAFD,MAEO;AACL,kBAAME,cAAc,SAAS,MAAI,CAACjB,QAAL,CAAce,YAAd,EAA4BlC,MAA5B,CAA7B;AACAgC,YAAAA,WAAW,GAAGnG,SAAS,CAACuG,cAAD,EAAiBvI,SAAjB,EAA4BkI,SAA5B,EAAuCG,YAAvC,CAAvB;AACD;AACF,SA7BgF,CA+BjF;;;AACA,YAAIH,SAAS,KAAK,CAAd,IAAmB3I,WAAW,CAACiJ,OAAZ,CAAoBP,QAApB,MAAkC,CAAC,CAAtD,IACC,EAAEjI,SAAS,KAAKX,UAAU,CAACsB,QAAzB,IAAqCX,SAAS,KAAKX,UAAU,CAACuB,SAAhE,CADL,EACiF;AAC/EgB,UAAAA,KAAK,GAAGuG,WAAW,CAAC,CAAD,CAAnB;AACD,SAHD,MAGO;AACLvG,UAAAA,KAAK,GAAGuG,WAAR;AACD,SArCgF,CAuCjF;;;AACAhH,QAAAA,aAAa,CAAC7B,aAAa,CAAC2I,QAAD,CAAd,CAAb,GAAyCrG,KAAzC;AACD;;AACD,YAAMN,eAAe,GAAGJ,oBAAoB,CAACC,aAAD,CAA5C;AACA,YAAM0C,iBAAiB,GAAG5B,SAAS,CAACqG,UAAV,CACxB3G,MAAM,GAAGiG,UAAT,GAAuBD,SAAS,GAAGE,aADX,CAA1B;AAIA,aAAO,IAAIlE,kBAAJ,CACLxC,aADK,EAELG,eAFK,EAGLuC,iBAHK,CAAP;AAnEiC;AAwElC;;AAEK4E,EAAAA,UAAU,CAAC1E,KAAD,EAAQ;AAAA;;AAAA;AACtB;AACA,UAAI,MAAI,CAACqD,WAAL,CAAiBrD,KAAjB,CAAJ,EAA6B;AAC3B;AACA,eAAO,MAAI,CAACqD,WAAL,CAAiBrD,KAAjB,CAAP;AACD,OAHD,MAGO,IAAIA,KAAK,KAAK,CAAd,EAAiB;AACtB;AACA,QAAA,MAAI,CAACqD,WAAL,CAAiBrD,KAAjB,IAA0B,MAAI,CAAC2D,oBAAL,CAA0B,MAAI,CAACR,cAA/B,CAA1B;AACA,eAAO,MAAI,CAACE,WAAL,CAAiBrD,KAAjB,CAAP;AACD,OAJM,MAIA,IAAI,CAAC,MAAI,CAACqD,WAAL,CAAiBrD,KAAK,GAAG,CAAzB,CAAL,EAAkC;AACvC;AACA;AACA,YAAI;AACF,UAAA,MAAI,CAACqD,WAAL,CAAiBrD,KAAK,GAAG,CAAzB,IAA8B,MAAI,CAAC0E,UAAL,CAAgB1E,KAAK,GAAG,CAAxB,CAA9B;AACD,SAFD,CAEE,OAAO2E,CAAP,EAAU;AACV;AACA;AACA,cAAIA,CAAC,YAAY5E,sBAAjB,EAAyC;AACvC,kBAAM,IAAIA,sBAAJ,CAA2BC,KAA3B,CAAN;AACD,WALS,CAMV;;;AACA,gBAAM2E,CAAN;AACD;AACF,OAvBqB,CAwBtB;AACA;;;AACA,MAAA,MAAI,CAACtB,WAAL,CAAiBrD,KAAjB,IAA0B,kBAAC,aAAY;AACrC,cAAM4E,WAAW,SAAS,MAAI,CAACvB,WAAL,CAAiBrD,KAAK,GAAG,CAAzB,CAA1B;;AACA,YAAI4E,WAAW,CAAC9E,iBAAZ,KAAkC,CAAtC,EAAyC;AACvC,gBAAM,IAAIC,sBAAJ,CAA2BC,KAA3B,CAAN;AACD;;AACD,eAAO,MAAI,CAAC2D,oBAAL,CAA0BiB,WAAW,CAAC9E,iBAAtC,CAAP;AACD,OANyB,GAA1B;AAOA,aAAO,MAAI,CAACuD,WAAL,CAAiBrD,KAAjB,CAAP;AAjCsB;AAkCvB;AAED;AACF;AACA;AACA;AACA;AACA;;;AACQY,EAAAA,QAAQ,CAACZ,KAAK,GAAG,CAAT,EAAY;AAAA;;AAAA;AACxB,YAAM6E,GAAG,SAAS,MAAI,CAACH,UAAL,CAAgB1E,KAAhB,CAAlB;AACA,aAAO,IAAIlF,YAAJ,CACL+J,GAAG,CAACzH,aADC,EACcyH,GAAG,CAACtH,eADlB,EAEL,MAAI,CAACuH,QAFA,EAEU,MAAI,CAAC7B,YAFf,EAE6B,MAAI,CAACG,KAFlC,EAEyC,MAAI,CAACJ,MAF9C,CAAP;AAFwB;AAMzB;AAED;AACF;AACA;AACA;AACA;;;AACQjC,EAAAA,aAAa,GAAG;AAAA;;AAAA;AACpB,UAAIf,KAAK,GAAG,CAAZ,CADoB,CAEpB;;AACA,UAAI+E,OAAO,GAAG,IAAd;;AACA,aAAOA,OAAP,EAAgB;AACd,YAAI;AACF,gBAAM,MAAI,CAACL,UAAL,CAAgB1E,KAAhB,CAAN;AACA,YAAEA,KAAF;AACD,SAHD,CAGE,OAAO2E,CAAP,EAAU;AACV,cAAIA,CAAC,YAAY5E,sBAAjB,EAAyC;AACvCgF,YAAAA,OAAO,GAAG,KAAV;AACD,WAFD,MAEO;AACL,kBAAMJ,CAAN;AACD;AACF;AACF;;AACD,aAAO3E,KAAP;AAhBoB;AAiBrB;AAED;AACF;AACA;AACA;AACA;;;AACQgF,EAAAA,cAAc,GAAG;AAAA;;AAAA;AACrB,YAAMpH,MAAM,GAAG,MAAI,CAACsF,OAAL,GAAe,EAAf,GAAoB,CAAnC;;AACA,UAAI,MAAI,CAACI,WAAT,EAAsB;AACpB,eAAO,MAAI,CAACA,WAAZ;AACD;;AACD,YAAM2B,eAAe,GAAG,gCAAxB;AACA,YAAMC,iBAAiB,GAAGD,eAAe,CAAC7C,MAAhB,GAAyB,GAAnD;AACA,UAAI+C,KAAK,SAAS,MAAI,CAAC5B,QAAL,CAAc3F,MAAd,EAAsBsH,iBAAtB,CAAlB;;AACA,UAAID,eAAe,KAAKhH,SAAS,CAACkH,KAAD,EAAQ7J,UAAU,CAACa,KAAnB,EAA0B8I,eAAe,CAAC7C,MAA1C,EAAkDxE,MAAlD,CAAjC,EAA4F;AAC1F,cAAMwH,YAAY,GAAGnH,SAAS,CAACkH,KAAD,EAAQ7J,UAAU,CAACa,KAAnB,EAA0B+I,iBAA1B,EAA6CtH,MAA7C,CAA9B;AACA,cAAMyH,SAAS,GAAGD,YAAY,CAACE,KAAb,CAAmB,IAAnB,EAAyB,CAAzB,CAAlB;AACA,cAAMC,YAAY,GAAGC,MAAM,CAACH,SAAS,CAACC,KAAV,CAAgB,GAAhB,EAAqB,CAArB,EAAwBA,KAAxB,CAA8B,GAA9B,EAAmC,CAAnC,CAAD,CAAN,GAAgDD,SAAS,CAACjD,MAA/E;;AACA,YAAImD,YAAY,GAAGL,iBAAnB,EAAsC;AACpCC,UAAAA,KAAK,SAAS,MAAI,CAAC5B,QAAL,CAAc3F,MAAd,EAAsB2H,YAAtB,CAAd;AACD;;AACD,cAAME,UAAU,GAAGxH,SAAS,CAACkH,KAAD,EAAQ7J,UAAU,CAACa,KAAnB,EAA0BoJ,YAA1B,EAAwC3H,MAAxC,CAA5B;AACA,QAAA,MAAI,CAAC0F,WAAL,GAAmB,EAAnB;AACAmC,QAAAA,UAAU,CACPH,KADH,CACS,IADT,EAEGI,MAFH,CAEWC,IAAD,IAAUA,IAAI,CAACvD,MAAL,GAAc,CAFlC,EAGGwD,GAHH,CAGQD,IAAD,IAAUA,IAAI,CAACL,KAAL,CAAW,GAAX,CAHjB,EAIGO,OAJH,CAIW,CAAC,CAACpI,GAAD,EAAMI,KAAN,CAAD,KAAkB;AACzB,UAAA,MAAI,CAACyF,WAAL,CAAiB7F,GAAjB,IAAwBI,KAAxB;AACD,SANH;AAOD;;AACD,aAAO,MAAI,CAACyF,WAAZ;AAzBqB;AA0BtB;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;AACyB,SAAVwC,UAAU,CAAC9C,MAAD,EAAS7C,OAAT,EAAkB4F,MAAlB,EAA0B;AAAA;AAC/C,YAAMC,UAAU,GAAG,OAAOhD,MAAM,CAACU,KAAP,CAAa,CAAC;AAAE9F,QAAAA,MAAM,EAAE,CAAV;AAAawE,QAAAA,MAAM,EAAE;AAArB,OAAD,CAAb,EAA4C2D,MAA5C,CAAP,EAA4D,CAA5D,CAAnB;AACA,YAAMjB,QAAQ,GAAG,IAAI/J,UAAJ,CAAeiL,UAAf,CAAjB;AAEA,YAAMC,GAAG,GAAGnB,QAAQ,CAACoB,SAAT,CAAmB,CAAnB,EAAsB,CAAtB,CAAZ;AACA,UAAIjD,YAAJ;;AACA,UAAIgD,GAAG,KAAK,MAAZ,EAAoB;AAClBhD,QAAAA,YAAY,GAAG,IAAf;AACD,OAFD,MAEO,IAAIgD,GAAG,KAAK,MAAZ,EAAoB;AACzBhD,QAAAA,YAAY,GAAG,KAAf;AACD,OAFM,MAEA;AACL,cAAM,IAAIkD,SAAJ,CAAc,2BAAd,CAAN;AACD;;AAED,YAAMC,WAAW,GAAGtB,QAAQ,CAACoB,SAAT,CAAmB,CAAnB,EAAsBjD,YAAtB,CAApB;AACA,UAAIC,OAAJ;;AACA,UAAIkD,WAAW,KAAK,EAApB,EAAwB;AACtBlD,QAAAA,OAAO,GAAG,KAAV;AACD,OAFD,MAEO,IAAIkD,WAAW,KAAK,EAApB,EAAwB;AAC7BlD,QAAAA,OAAO,GAAG,IAAV;AACA,cAAMmD,cAAc,GAAGvB,QAAQ,CAACoB,SAAT,CAAmB,CAAnB,EAAsBjD,YAAtB,CAAvB;;AACA,YAAIoD,cAAc,KAAK,CAAvB,EAA0B;AACxB,gBAAM,IAAIvI,KAAJ,CAAU,+BAAV,CAAN;AACD;AACF,OANM,MAMA;AACL,cAAM,IAAIqI,SAAJ,CAAc,uBAAd,CAAN;AACD;;AAED,YAAMhD,cAAc,GAAGD,OAAO,GAC1B4B,QAAQ,CAACwB,SAAT,CAAmB,CAAnB,EAAsBrD,YAAtB,CAD0B,GAE1B6B,QAAQ,CAACyB,SAAT,CAAmB,CAAnB,EAAsBtD,YAAtB,CAFJ;AAGA,aAAO,IAAIF,OAAJ,CAAYC,MAAZ,EAAoBC,YAApB,EAAkCC,OAAlC,EAA2CC,cAA3C,EAA2DhD,OAA3D,CAAP;AA/B+C;AAgChD;AAED;AACF;AACA;AACA;AACA;;;AACEqG,EAAAA,KAAK,GAAG;AACN,QAAI,OAAO,KAAKxD,MAAL,CAAYwD,KAAnB,KAA6B,UAAjC,EAA6C;AAC3C,aAAO,KAAKxD,MAAL,CAAYwD,KAAZ,EAAP;AACD;;AACD,WAAO,KAAP;AACD;;AApR+B;;AAuRlC,SAASzD,OAAT;AACA,eAAeA,OAAf;AAEA;AACA;AACA;AACA;;AACA,MAAM0D,YAAN,SAA2BxG,WAA3B,CAAuC;AACrC;AACF;AACA;AACA;AACA;AACEJ,EAAAA,WAAW,CAAC6G,QAAD,EAAWC,aAAX,EAA0B;AACnC;AACA,SAAKD,QAAL,GAAgBA,QAAhB;AACA,SAAKC,aAAL,GAAqBA,aAArB;AACA,SAAKC,UAAL,GAAkB,CAACF,QAAD,EAAWG,MAAX,CAAkBF,aAAlB,CAAlB;AAEA,SAAKG,sBAAL,GAA8B,IAA9B;AACA,SAAKC,6BAAL,GAAqC,IAArC;AACA,SAAKjG,UAAL,GAAkB,IAAlB;AACD;;AAEKkG,EAAAA,2BAA2B,GAAG;AAAA;;AAAA;AAClC,YAAMC,QAAQ,GAAG,CAAC,MAAI,CAACP,QAAL,CAAc/C,oBAAd,CAAmC,MAAI,CAAC+C,QAAL,CAAcvD,cAAjD,CAAD,EACd0D,MADc,CACP,MAAI,CAACF,aAAL,CAAmBf,GAAnB,CAAwBsB,IAAD,IAAUA,IAAI,CAACvD,oBAAL,CAA0BuD,IAAI,CAAC/D,cAA/B,CAAjC,CADO,CAAjB;AAGA,MAAA,MAAI,CAAC2D,sBAAL,SAAoCK,OAAO,CAACC,GAAR,CAAYH,QAAZ,CAApC;AACA,aAAO,MAAI,CAACH,sBAAZ;AALkC;AAMnC;AAED;AACF;AACA;AACA;AACA;AACA;;;AACQlG,EAAAA,QAAQ,CAACZ,KAAK,GAAG,CAAT,EAAY;AAAA;;AAAA;AACxB,YAAM,MAAI,CAACe,aAAL,EAAN;AACA,YAAM,MAAI,CAACiG,2BAAL,EAAN;AACA,UAAIK,OAAO,GAAG,CAAd;AACA,UAAIC,aAAa,GAAG,CAApB;;AACA,WAAK,IAAI9J,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,MAAI,CAACoJ,UAAL,CAAgBxE,MAApC,EAA4C5E,CAAC,EAA7C,EAAiD;AAC/C,cAAM+J,SAAS,GAAG,MAAI,CAACX,UAAL,CAAgBpJ,CAAhB,CAAlB;;AACA,aAAK,IAAIgK,EAAE,GAAG,CAAd,EAAiBA,EAAE,GAAG,MAAI,CAACC,WAAL,CAAiBjK,CAAjB,CAAtB,EAA2CgK,EAAE,EAA7C,EAAiD;AAC/C,cAAIxH,KAAK,KAAKqH,OAAd,EAAuB;AACrB,kBAAMxC,GAAG,SAAS0C,SAAS,CAAC7C,UAAV,CAAqB4C,aAArB,CAAlB;AACA,mBAAO,IAAIxM,YAAJ,CACL+J,GAAG,CAACzH,aADC,EACcyH,GAAG,CAACtH,eADlB,EAELgK,SAAS,CAACzC,QAFL,EAEeyC,SAAS,CAACtE,YAFzB,EAEuCsE,SAAS,CAACnE,KAFjD,EAEwDmE,SAAS,CAACvE,MAFlE,CAAP;AAID;;AACDqE,UAAAA,OAAO;AACPC,UAAAA,aAAa;AACd;;AACDA,QAAAA,aAAa,GAAG,CAAhB;AACD;;AAED,YAAM,IAAIpK,UAAJ,CAAe,qBAAf,CAAN;AArBwB;AAsBzB;AAED;AACF;AACA;AACA;AACA;;;AACQ6D,EAAAA,aAAa,GAAG;AAAA;;AAAA;AACpB,UAAI,OAAI,CAACD,UAAL,KAAoB,IAAxB,EAA8B;AAC5B,eAAO,OAAI,CAACA,UAAZ;AACD;;AACD,YAAMmG,QAAQ,GAAG,CAAC,OAAI,CAACP,QAAL,CAAc3F,aAAd,EAAD,EACd8F,MADc,CACP,OAAI,CAACF,aAAL,CAAmBf,GAAnB,CAAwBsB,IAAD,IAAUA,IAAI,CAACnG,aAAL,EAAjC,CADO,CAAjB;AAEA,MAAA,OAAI,CAAC0G,WAAL,SAAyBN,OAAO,CAACC,GAAR,CAAYH,QAAZ,CAAzB;AACA,MAAA,OAAI,CAACnG,UAAL,GAAkB,OAAI,CAAC2G,WAAL,CAAiBC,MAAjB,CAAwB,CAAC/J,KAAD,EAAQgK,IAAR,KAAiBhK,KAAK,GAAGgK,IAAjD,EAAuD,CAAvD,CAAlB;AACA,aAAO,OAAI,CAAC7G,UAAZ;AARoB;AASrB;;AArEoC;;AAwEvC,SAAS2F,YAAT;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,gBAAsBmB,OAAtB;AAAA;AAAA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;+BAXO,WAAuBC,GAAvB,EAA4B1H,OAAO,GAAG,EAAtC,EAA0C4F,MAA1C,EAAkD;AACvD,WAAOhD,OAAO,CAAC+C,UAAR,CAAmB5K,gBAAgB,CAAC2M,GAAD,EAAM1H,OAAN,CAAnC,EAAmD4F,MAAnD,CAAP;AACD,G;;;;AAUD,gBAAsB+B,eAAtB;AAAA;AAAA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;uCAfO,WAA+BC,WAA/B,EAA4ChC,MAA5C,EAAoD;AACzD,WAAOhD,OAAO,CAAC+C,UAAR,CAAmB3K,gBAAgB,CAAC4M,WAAD,CAAnC,EAAkDhC,MAAlD,CAAP;AACD,G;;;;AAcD,gBAAsBiC,QAAtB;AAAA;AAAA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;gCAbO,WAAwBC,IAAxB,EAA8BlC,MAA9B,EAAsC;AAC3C,WAAOhD,OAAO,CAAC+C,UAAR,CAAmBzK,cAAc,CAAC4M,IAAD,CAAjC,EAAyClC,MAAzC,CAAP;AACD,G;;;;AAYD,gBAAsBmC,QAAtB;AAAA;AAAA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;gCAdO,WAAwBC,IAAxB,EAA8BpC,MAA9B,EAAsC;AAC3C,WAAOhD,OAAO,CAAC+C,UAAR,CAAmB1K,oBAAoB,CAAC+M,IAAD,CAAvC,EAA+CpC,MAA/C,CAAP;AACD,G;;;;AAaD,gBAAsBqC,QAAtB;AAAA;AAAA;AASA;AACA;AACA;AACA;AACA;;;gCAbO,WAAwBC,OAAxB,EAAiCC,YAAY,GAAG,EAAhD,EAAoDnI,OAAO,GAAG,EAA9D,EAAkE4F,MAAlE,EAA0E;AAC/E,UAAMW,QAAQ,SAAS3D,OAAO,CAAC+C,UAAR,CAAmB5K,gBAAgB,CAACmN,OAAD,EAAUlI,OAAV,CAAnC,EAAuD4F,MAAvD,CAAvB;AACA,UAAMY,aAAa,SAASQ,OAAO,CAACC,GAAR,CAC1BkB,YAAY,CAAC1C,GAAb,CAAkBiC,GAAD,IAAS9E,OAAO,CAAC+C,UAAR,CAAmB5K,gBAAgB,CAAC2M,GAAD,EAAM1H,OAAN,CAAnC,CAA1B,CAD0B,CAA5B;AAIA,WAAO,IAAIsG,YAAJ,CAAiBC,QAAjB,EAA2BC,aAA3B,CAAP;AACD,G;;;;AAOD,gBAAsB4B,gBAAtB;AAAA;AAAA;;;wCAAO,WAAgCpK,MAAhC,EAAwCqK,QAAxC,EAAkD;AACvD,WAAO9M,YAAY,CAACyC,MAAD,EAASqK,QAAT,CAAnB;AACD,G;;;;AAED,SAASvN,IAAT","sourcesContent":["import GeoTIFFImage from './geotiffimage';\nimport DataView64 from './dataview64';\nimport DataSlice from './dataslice';\nimport Pool from './pool';\n\nimport { makeRemoteSource } from './source/remote';\nimport { makeBufferSource } from './source/arraybuffer';\nimport { makeFileReaderSource } from './source/filereader';\nimport { makeFileSource } from './source/file';\n\nimport { fieldTypes, fieldTagNames, arrayFields, geoKeyNames } from './globals';\nimport { writeGeotiff } from './geotiffwriter';\nimport * as globals from './globals';\nimport * as rgb from './rgb';\nimport { getDecoder, addDecoder } from './compression';\nimport { setLogger } from './logging';\n\nexport { globals };\nexport { rgb };\nexport { getDecoder, addDecoder };\nexport { setLogger };\n\nfunction getFieldTypeLength(fieldType) {\n  switch (fieldType) {\n    case fieldTypes.BYTE: case fieldTypes.ASCII: case fieldTypes.SBYTE: case fieldTypes.UNDEFINED:\n      return 1;\n    case fieldTypes.SHORT: case fieldTypes.SSHORT:\n      return 2;\n    case fieldTypes.LONG: case fieldTypes.SLONG: case fieldTypes.FLOAT: case fieldTypes.IFD:\n      return 4;\n    case fieldTypes.RATIONAL: case fieldTypes.SRATIONAL: case fieldTypes.DOUBLE:\n    case fieldTypes.LONG8: case fieldTypes.SLONG8: case fieldTypes.IFD8:\n      return 8;\n    default:\n      throw new RangeError(`Invalid field type: ${fieldType}`);\n  }\n}\n\nfunction parseGeoKeyDirectory(fileDirectory) {\n  const rawGeoKeyDirectory = fileDirectory.GeoKeyDirectory;\n  if (!rawGeoKeyDirectory) {\n    return null;\n  }\n\n  const geoKeyDirectory = {};\n  for (let i = 4; i <= rawGeoKeyDirectory[3] * 4; i += 4) {\n    const key = geoKeyNames[rawGeoKeyDirectory[i]];\n    const location = (rawGeoKeyDirectory[i + 1])\n      ? (fieldTagNames[rawGeoKeyDirectory[i + 1]]) : null;\n    const count = rawGeoKeyDirectory[i + 2];\n    const offset = rawGeoKeyDirectory[i + 3];\n\n    let value = null;\n    if (!location) {\n      value = offset;\n    } else {\n      value = fileDirectory[location];\n      if (typeof value === 'undefined' || value === null) {\n        throw new Error(`Could not get value of geoKey '${key}'.`);\n      } else if (typeof value === 'string') {\n        value = value.substring(offset, offset + count - 1);\n      } else if (value.subarray) {\n        value = value.subarray(offset, offset + count);\n        if (count === 1) {\n          value = value[0];\n        }\n      }\n    }\n    geoKeyDirectory[key] = value;\n  }\n  return geoKeyDirectory;\n}\n\nfunction getValues(dataSlice, fieldType, count, offset) {\n  let values = null;\n  let readMethod = null;\n  const fieldTypeLength = getFieldTypeLength(fieldType);\n\n  switch (fieldType) {\n    case fieldTypes.BYTE: case fieldTypes.ASCII: case fieldTypes.UNDEFINED:\n      values = new Uint8Array(count); readMethod = dataSlice.readUint8;\n      break;\n    case fieldTypes.SBYTE:\n      values = new Int8Array(count); readMethod = dataSlice.readInt8;\n      break;\n    case fieldTypes.SHORT:\n      values = new Uint16Array(count); readMethod = dataSlice.readUint16;\n      break;\n    case fieldTypes.SSHORT:\n      values = new Int16Array(count); readMethod = dataSlice.readInt16;\n      break;\n    case fieldTypes.LONG: case fieldTypes.IFD:\n      values = new Uint32Array(count); readMethod = dataSlice.readUint32;\n      break;\n    case fieldTypes.SLONG:\n      values = new Int32Array(count); readMethod = dataSlice.readInt32;\n      break;\n    case fieldTypes.LONG8: case fieldTypes.IFD8:\n      values = new Array(count); readMethod = dataSlice.readUint64;\n      break;\n    case fieldTypes.SLONG8:\n      values = new Array(count); readMethod = dataSlice.readInt64;\n      break;\n    case fieldTypes.RATIONAL:\n      values = new Uint32Array(count * 2); readMethod = dataSlice.readUint32;\n      break;\n    case fieldTypes.SRATIONAL:\n      values = new Int32Array(count * 2); readMethod = dataSlice.readInt32;\n      break;\n    case fieldTypes.FLOAT:\n      values = new Float32Array(count); readMethod = dataSlice.readFloat32;\n      break;\n    case fieldTypes.DOUBLE:\n      values = new Float64Array(count); readMethod = dataSlice.readFloat64;\n      break;\n    default:\n      throw new RangeError(`Invalid field type: ${fieldType}`);\n  }\n\n  // normal fields\n  if (!(fieldType === fieldTypes.RATIONAL || fieldType === fieldTypes.SRATIONAL)) {\n    for (let i = 0; i < count; ++i) {\n      values[i] = readMethod.call(\n        dataSlice, offset + (i * fieldTypeLength),\n      );\n    }\n  } else { // RATIONAL or SRATIONAL\n    for (let i = 0; i < count; i += 2) {\n      values[i] = readMethod.call(\n        dataSlice, offset + (i * fieldTypeLength),\n      );\n      values[i + 1] = readMethod.call(\n        dataSlice, offset + ((i * fieldTypeLength) + 4),\n      );\n    }\n  }\n\n  if (fieldType === fieldTypes.ASCII) {\n    return new TextDecoder('utf-8').decode(values);\n  }\n  return values;\n}\n\n/**\n * Data class to store the parsed file directory, geo key directory and\n * offset to the next IFD\n */\nclass ImageFileDirectory {\n  constructor(fileDirectory, geoKeyDirectory, nextIFDByteOffset) {\n    this.fileDirectory = fileDirectory;\n    this.geoKeyDirectory = geoKeyDirectory;\n    this.nextIFDByteOffset = nextIFDByteOffset;\n  }\n}\n\n/**\n * Error class for cases when an IFD index was requested, that does not exist\n * in the file.\n */\nclass GeoTIFFImageIndexError extends Error {\n  constructor(index) {\n    super(`No image at index ${index}`);\n    this.index = index;\n  }\n}\n\nclass GeoTIFFBase {\n  /**\n   * (experimental) Reads raster data from the best fitting image. This function uses\n   * the image with the lowest resolution that is still a higher resolution than the\n   * requested resolution.\n   * When specified, the `bbox` option is translated to the `window` option and the\n   * `resX` and `resY` to `width` and `height` respectively.\n   * Then, the [readRasters]{@link GeoTIFFImage#readRasters} method of the selected\n   * image is called and the result returned.\n   * @see GeoTIFFImage.readRasters\n   * @param {Object} [options={}] optional parameters\n   * @param {Array} [options.window=whole image] the subset to read data from.\n   * @param {Array} [options.bbox=whole image] the subset to read data from in\n   *                                           geographical coordinates.\n   * @param {Array} [options.samples=all samples] the selection of samples to read from.\n   * @param {Boolean} [options.interleave=false] whether the data shall be read\n   *                                             in one single array or separate\n   *                                             arrays.\n   * @param {Number} [options.pool=null] The optional decoder pool to use.\n   * @param {Number} [options.width] The desired width of the output. When the width is not the\n   *                                 same as the images, resampling will be performed.\n   * @param {Number} [options.height] The desired height of the output. When the width is not the\n   *                                  same as the images, resampling will be performed.\n   * @param {String} [options.resampleMethod='nearest'] The desired resampling method.\n   * @param {AbortSignal} [options.signal] An AbortSignal that may be signalled if the request is\n   *                                       to be aborted\n   * @param {Number|Number[]} [options.fillValue] The value to use for parts of the image\n   *                                              outside of the images extent. When multiple\n   *                                              samples are requested, an array of fill values\n   *                                              can be passed.\n   * @returns {Promise.<(TypedArray|TypedArray[])>} the decoded arrays as a promise\n   */\n  async readRasters(options = {}) {\n    const { window: imageWindow, width, height } = options;\n    let { resX, resY, bbox } = options;\n\n    const firstImage = await this.getImage();\n    let usedImage = firstImage;\n    const imageCount = await this.getImageCount();\n    const imgBBox = firstImage.getBoundingBox();\n\n    if (imageWindow && bbox) {\n      throw new Error('Both \"bbox\" and \"window\" passed.');\n    }\n\n    // if width/height is passed, transform it to resolution\n    if (width || height) {\n      // if we have an image window (pixel coordinates), transform it to a BBox\n      // using the origin/resolution of the first image.\n      if (imageWindow) {\n        const [oX, oY] = firstImage.getOrigin();\n        const [rX, rY] = firstImage.getResolution();\n\n        bbox = [\n          oX + (imageWindow[0] * rX),\n          oY + (imageWindow[1] * rY),\n          oX + (imageWindow[2] * rX),\n          oY + (imageWindow[3] * rY),\n        ];\n      }\n\n      // if we have a bbox (or calculated one)\n\n      const usedBBox = bbox || imgBBox;\n\n      if (width) {\n        if (resX) {\n          throw new Error('Both width and resX passed');\n        }\n        resX = (usedBBox[2] - usedBBox[0]) / width;\n      }\n      if (height) {\n        if (resY) {\n          throw new Error('Both width and resY passed');\n        }\n        resY = (usedBBox[3] - usedBBox[1]) / height;\n      }\n    }\n\n    // if resolution is set or calculated, try to get the image with the worst acceptable resolution\n    if (resX || resY) {\n      const allImages = [];\n      for (let i = 0; i < imageCount; ++i) {\n        const image = await this.getImage(i);\n        const { SubfileType: subfileType, NewSubfileType: newSubfileType } = image.fileDirectory;\n        if (i === 0 || subfileType === 2 || newSubfileType & 1) {\n          allImages.push(image);\n        }\n      }\n\n      allImages.sort((a, b) => a.getWidth() - b.getWidth());\n      for (let i = 0; i < allImages.length; ++i) {\n        const image = allImages[i];\n        const imgResX = (imgBBox[2] - imgBBox[0]) / image.getWidth();\n        const imgResY = (imgBBox[3] - imgBBox[1]) / image.getHeight();\n\n        usedImage = image;\n        if ((resX && resX > imgResX) || (resY && resY > imgResY)) {\n          break;\n        }\n      }\n    }\n\n    let wnd = imageWindow;\n    if (bbox) {\n      const [oX, oY] = firstImage.getOrigin();\n      const [imageResX, imageResY] = usedImage.getResolution(firstImage);\n\n      wnd = [\n        Math.round((bbox[0] - oX) / imageResX),\n        Math.round((bbox[1] - oY) / imageResY),\n        Math.round((bbox[2] - oX) / imageResX),\n        Math.round((bbox[3] - oY) / imageResY),\n      ];\n      wnd = [\n        Math.min(wnd[0], wnd[2]),\n        Math.min(wnd[1], wnd[3]),\n        Math.max(wnd[0], wnd[2]),\n        Math.max(wnd[1], wnd[3]),\n      ];\n    }\n\n    return usedImage.readRasters({ ...options, window: wnd });\n  }\n}\n\n/**\n * The abstraction for a whole GeoTIFF file.\n * @augments GeoTIFFBase\n */\nclass GeoTIFF extends GeoTIFFBase {\n  /**\n   * @constructor\n   * @param {Source} source The datasource to read from.\n   * @param {Boolean} littleEndian Whether the image uses little endian.\n   * @param {Boolean} bigTiff Whether the image uses bigTIFF conventions.\n   * @param {Number} firstIFDOffset The numeric byte-offset from the start of the image\n   *                                to the first IFD.\n   * @param {Object} [options] further options.\n   * @param {Boolean} [options.cache=false] whether or not decoded tiles shall be cached.\n   */\n  constructor(source, littleEndian, bigTiff, firstIFDOffset, options = {}) {\n    super();\n    this.source = source;\n    this.littleEndian = littleEndian;\n    this.bigTiff = bigTiff;\n    this.firstIFDOffset = firstIFDOffset;\n    this.cache = options.cache || false;\n    this.ifdRequests = [];\n    this.ghostValues = null;\n  }\n\n  async getSlice(offset, size) {\n    const fallbackSize = this.bigTiff ? 4048 : 1024;\n    return new DataSlice(\n      (await this.source.fetch([{\n        offset,\n        length: typeof size !== 'undefined' ? size : fallbackSize,\n      }]))[0],\n      offset,\n      this.littleEndian,\n      this.bigTiff,\n    );\n  }\n\n  /**\n   * Instructs to parse an image file directory at the given file offset.\n   * As there is no way to ensure that a location is indeed the start of an IFD,\n   * this function must be called with caution (e.g only using the IFD offsets from\n   * the headers or other IFDs).\n   * @param {number} offset the offset to parse the IFD at\n   * @returns {ImageFileDirectory} the parsed IFD\n   */\n  async parseFileDirectoryAt(offset) {\n    const entrySize = this.bigTiff ? 20 : 12;\n    const offsetSize = this.bigTiff ? 8 : 2;\n\n    let dataSlice = await this.getSlice(offset);\n    const numDirEntries = this.bigTiff\n      ? dataSlice.readUint64(offset)\n      : dataSlice.readUint16(offset);\n\n    // if the slice does not cover the whole IFD, request a bigger slice, where the\n    // whole IFD fits: num of entries + n x tag length + offset to next IFD\n    const byteSize = (numDirEntries * entrySize) + (this.bigTiff ? 16 : 6);\n    if (!dataSlice.covers(offset, byteSize)) {\n      dataSlice = await this.getSlice(offset, byteSize);\n    }\n\n    const fileDirectory = {};\n\n    // loop over the IFD and create a file directory object\n    let i = offset + (this.bigTiff ? 8 : 2);\n    for (let entryCount = 0; entryCount < numDirEntries; i += entrySize, ++entryCount) {\n      const fieldTag = dataSlice.readUint16(i);\n      const fieldType = dataSlice.readUint16(i + 2);\n      const typeCount = this.bigTiff\n        ? dataSlice.readUint64(i + 4)\n        : dataSlice.readUint32(i + 4);\n\n      let fieldValues;\n      let value;\n      const fieldTypeLength = getFieldTypeLength(fieldType);\n      const valueOffset = i + (this.bigTiff ? 12 : 8);\n\n      // check whether the value is directly encoded in the tag or refers to a\n      // different external byte range\n      if (fieldTypeLength * typeCount <= (this.bigTiff ? 8 : 4)) {\n        fieldValues = getValues(dataSlice, fieldType, typeCount, valueOffset);\n      } else {\n        // resolve the reference to the actual byte range\n        const actualOffset = dataSlice.readOffset(valueOffset);\n        const length = getFieldTypeLength(fieldType) * typeCount;\n\n        // check, whether we actually cover the referenced byte range; if not,\n        // request a new slice of bytes to read from it\n        if (dataSlice.covers(actualOffset, length)) {\n          fieldValues = getValues(dataSlice, fieldType, typeCount, actualOffset);\n        } else {\n          const fieldDataSlice = await this.getSlice(actualOffset, length);\n          fieldValues = getValues(fieldDataSlice, fieldType, typeCount, actualOffset);\n        }\n      }\n\n      // unpack single values from the array\n      if (typeCount === 1 && arrayFields.indexOf(fieldTag) === -1\n        && !(fieldType === fieldTypes.RATIONAL || fieldType === fieldTypes.SRATIONAL)) {\n        value = fieldValues[0];\n      } else {\n        value = fieldValues;\n      }\n\n      // write the tags value to the file directly\n      fileDirectory[fieldTagNames[fieldTag]] = value;\n    }\n    const geoKeyDirectory = parseGeoKeyDirectory(fileDirectory);\n    const nextIFDByteOffset = dataSlice.readOffset(\n      offset + offsetSize + (entrySize * numDirEntries),\n    );\n\n    return new ImageFileDirectory(\n      fileDirectory,\n      geoKeyDirectory,\n      nextIFDByteOffset,\n    );\n  }\n\n  async requestIFD(index) {\n    // see if we already have that IFD index requested.\n    if (this.ifdRequests[index]) {\n      // attach to an already requested IFD\n      return this.ifdRequests[index];\n    } else if (index === 0) {\n      // special case for index 0\n      this.ifdRequests[index] = this.parseFileDirectoryAt(this.firstIFDOffset);\n      return this.ifdRequests[index];\n    } else if (!this.ifdRequests[index - 1]) {\n      // if the previous IFD was not yet loaded, load that one first\n      // this is the recursive call.\n      try {\n        this.ifdRequests[index - 1] = this.requestIFD(index - 1);\n      } catch (e) {\n        // if the previous one already was an index error, rethrow\n        // with the current index\n        if (e instanceof GeoTIFFImageIndexError) {\n          throw new GeoTIFFImageIndexError(index);\n        }\n        // rethrow anything else\n        throw e;\n      }\n    }\n    // if the previous IFD was loaded, we can finally fetch the one we are interested in.\n    // we need to wrap this in an IIFE, otherwise this.ifdRequests[index] would be delayed\n    this.ifdRequests[index] = (async () => {\n      const previousIfd = await this.ifdRequests[index - 1];\n      if (previousIfd.nextIFDByteOffset === 0) {\n        throw new GeoTIFFImageIndexError(index);\n      }\n      return this.parseFileDirectoryAt(previousIfd.nextIFDByteOffset);\n    })();\n    return this.ifdRequests[index];\n  }\n\n  /**\n   * Get the n-th internal subfile of an image. By default, the first is returned.\n   *\n   * @param {Number} [index=0] the index of the image to return.\n   * @returns {GeoTIFFImage} the image at the given index\n   */\n  async getImage(index = 0) {\n    const ifd = await this.requestIFD(index);\n    return new GeoTIFFImage(\n      ifd.fileDirectory, ifd.geoKeyDirectory,\n      this.dataView, this.littleEndian, this.cache, this.source,\n    );\n  }\n\n  /**\n   * Returns the count of the internal subfiles.\n   *\n   * @returns {Number} the number of internal subfile images\n   */\n  async getImageCount() {\n    let index = 0;\n    // loop until we run out of IFDs\n    let hasNext = true;\n    while (hasNext) {\n      try {\n        await this.requestIFD(index);\n        ++index;\n      } catch (e) {\n        if (e instanceof GeoTIFFImageIndexError) {\n          hasNext = false;\n        } else {\n          throw e;\n        }\n      }\n    }\n    return index;\n  }\n\n  /**\n   * Get the values of the COG ghost area as a parsed map.\n   * See https://gdal.org/drivers/raster/cog.html#header-ghost-area for reference\n   * @returns {Object} the parsed ghost area or null, if no such area was found\n   */\n  async getGhostValues() {\n    const offset = this.bigTiff ? 16 : 8;\n    if (this.ghostValues) {\n      return this.ghostValues;\n    }\n    const detectionString = 'GDAL_STRUCTURAL_METADATA_SIZE=';\n    const heuristicAreaSize = detectionString.length + 100;\n    let slice = await this.getSlice(offset, heuristicAreaSize);\n    if (detectionString === getValues(slice, fieldTypes.ASCII, detectionString.length, offset)) {\n      const valuesString = getValues(slice, fieldTypes.ASCII, heuristicAreaSize, offset);\n      const firstLine = valuesString.split('\\n')[0];\n      const metadataSize = Number(firstLine.split('=')[1].split(' ')[0]) + firstLine.length;\n      if (metadataSize > heuristicAreaSize) {\n        slice = await this.getSlice(offset, metadataSize);\n      }\n      const fullString = getValues(slice, fieldTypes.ASCII, metadataSize, offset);\n      this.ghostValues = {};\n      fullString\n        .split('\\n')\n        .filter((line) => line.length > 0)\n        .map((line) => line.split('='))\n        .forEach(([key, value]) => {\n          this.ghostValues[key] = value;\n        });\n    }\n    return this.ghostValues;\n  }\n\n  /**\n   * Parse a (Geo)TIFF file from the given source.\n   *\n   * @param {source~Source} source The source of data to parse from.\n   * @param {object} options Additional options.\n   * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n   *                               to be aborted\n   */\n  static async fromSource(source, options, signal) {\n    const headerData = (await source.fetch([{ offset: 0, length: 1024 }], signal))[0];\n    const dataView = new DataView64(headerData);\n\n    const BOM = dataView.getUint16(0, 0);\n    let littleEndian;\n    if (BOM === 0x4949) {\n      littleEndian = true;\n    } else if (BOM === 0x4D4D) {\n      littleEndian = false;\n    } else {\n      throw new TypeError('Invalid byte order value.');\n    }\n\n    const magicNumber = dataView.getUint16(2, littleEndian);\n    let bigTiff;\n    if (magicNumber === 42) {\n      bigTiff = false;\n    } else if (magicNumber === 43) {\n      bigTiff = true;\n      const offsetByteSize = dataView.getUint16(4, littleEndian);\n      if (offsetByteSize !== 8) {\n        throw new Error('Unsupported offset byte-size.');\n      }\n    } else {\n      throw new TypeError('Invalid magic number.');\n    }\n\n    const firstIFDOffset = bigTiff\n      ? dataView.getUint64(8, littleEndian)\n      : dataView.getUint32(4, littleEndian);\n    return new GeoTIFF(source, littleEndian, bigTiff, firstIFDOffset, options);\n  }\n\n  /**\n   * Closes the underlying file buffer\n   * N.B. After the GeoTIFF has been completely processed it needs\n   * to be closed but only if it has been constructed from a file.\n   */\n  close() {\n    if (typeof this.source.close === 'function') {\n      return this.source.close();\n    }\n    return false;\n  }\n}\n\nexport { GeoTIFF };\nexport default GeoTIFF;\n\n/**\n * Wrapper for GeoTIFF files that have external overviews.\n * @augments GeoTIFFBase\n */\nclass MultiGeoTIFF extends GeoTIFFBase {\n  /**\n   * Construct a new MultiGeoTIFF from a main and several overview files.\n   * @param {GeoTIFF} mainFile The main GeoTIFF file.\n   * @param {GeoTIFF[]} overviewFiles An array of overview files.\n   */\n  constructor(mainFile, overviewFiles) {\n    super();\n    this.mainFile = mainFile;\n    this.overviewFiles = overviewFiles;\n    this.imageFiles = [mainFile].concat(overviewFiles);\n\n    this.fileDirectoriesPerFile = null;\n    this.fileDirectoriesPerFileParsing = null;\n    this.imageCount = null;\n  }\n\n  async parseFileDirectoriesPerFile() {\n    const requests = [this.mainFile.parseFileDirectoryAt(this.mainFile.firstIFDOffset)]\n      .concat(this.overviewFiles.map((file) => file.parseFileDirectoryAt(file.firstIFDOffset)));\n\n    this.fileDirectoriesPerFile = await Promise.all(requests);\n    return this.fileDirectoriesPerFile;\n  }\n\n  /**\n   * Get the n-th internal subfile of an image. By default, the first is returned.\n   *\n   * @param {Number} [index=0] the index of the image to return.\n   * @returns {GeoTIFFImage} the image at the given index\n   */\n  async getImage(index = 0) {\n    await this.getImageCount();\n    await this.parseFileDirectoriesPerFile();\n    let visited = 0;\n    let relativeIndex = 0;\n    for (let i = 0; i < this.imageFiles.length; i++) {\n      const imageFile = this.imageFiles[i];\n      for (let ii = 0; ii < this.imageCounts[i]; ii++) {\n        if (index === visited) {\n          const ifd = await imageFile.requestIFD(relativeIndex);\n          return new GeoTIFFImage(\n            ifd.fileDirectory, ifd.geoKeyDirectory,\n            imageFile.dataView, imageFile.littleEndian, imageFile.cache, imageFile.source,\n          );\n        }\n        visited++;\n        relativeIndex++;\n      }\n      relativeIndex = 0;\n    }\n\n    throw new RangeError('Invalid image index');\n  }\n\n  /**\n   * Returns the count of the internal subfiles.\n   *\n   * @returns {Number} the number of internal subfile images\n   */\n  async getImageCount() {\n    if (this.imageCount !== null) {\n      return this.imageCount;\n    }\n    const requests = [this.mainFile.getImageCount()]\n      .concat(this.overviewFiles.map((file) => file.getImageCount()));\n    this.imageCounts = await Promise.all(requests);\n    this.imageCount = this.imageCounts.reduce((count, ifds) => count + ifds, 0);\n    return this.imageCount;\n  }\n}\n\nexport { MultiGeoTIFF };\n\n/**\n * Creates a new GeoTIFF from a remote URL.\n * @param {string} url The URL to access the image from\n * @param {object} [options] Additional options to pass to the source.\n *                           See {@link makeRemoteSource} for details.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise.<GeoTIFF>} The resulting GeoTIFF file.\n */\nexport async function fromUrl(url, options = {}, signal) {\n  return GeoTIFF.fromSource(makeRemoteSource(url, options), signal);\n}\n\n/**\n * Construct a new GeoTIFF from an\n * [ArrayBuffer]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer}.\n * @param {ArrayBuffer} arrayBuffer The data to read the file from.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise.<GeoTIFF>} The resulting GeoTIFF file.\n */\nexport async function fromArrayBuffer(arrayBuffer, signal) {\n  return GeoTIFF.fromSource(makeBufferSource(arrayBuffer), signal);\n}\n\n/**\n * Construct a GeoTIFF from a local file path. This uses the node\n * [filesystem API]{@link https://nodejs.org/api/fs.html} and is\n * not available on browsers.\n *\n * N.B. After the GeoTIFF has been completely processed it needs\n * to be closed but only if it has been constructed from a file.\n * @param {string} path The file path to read from.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise.<GeoTIFF>} The resulting GeoTIFF file.\n */\nexport async function fromFile(path, signal) {\n  return GeoTIFF.fromSource(makeFileSource(path), signal);\n}\n\n/**\n * Construct a GeoTIFF from an HTML\n * [Blob]{@link https://developer.mozilla.org/en-US/docs/Web/API/Blob} or\n * [File]{@link https://developer.mozilla.org/en-US/docs/Web/API/File}\n * object.\n * @param {Blob|File} blob The Blob or File object to read from.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise.<GeoTIFF>} The resulting GeoTIFF file.\n */\nexport async function fromBlob(blob, signal) {\n  return GeoTIFF.fromSource(makeFileReaderSource(blob), signal);\n}\n\n/**\n * Construct a MultiGeoTIFF from the given URLs.\n * @param {string} mainUrl The URL for the main file.\n * @param {string[]} overviewUrls An array of URLs for the overview images.\n * @param {object} [options] Additional options to pass to the source.\n *                           See [makeRemoteSource]{@link module:source.makeRemoteSource}\n *                           for details.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise.<MultiGeoTIFF>} The resulting MultiGeoTIFF file.\n */\nexport async function fromUrls(mainUrl, overviewUrls = [], options = {}, signal) {\n  const mainFile = await GeoTIFF.fromSource(makeRemoteSource(mainUrl, options), signal);\n  const overviewFiles = await Promise.all(\n    overviewUrls.map((url) => GeoTIFF.fromSource(makeRemoteSource(url, options))),\n  );\n\n  return new MultiGeoTIFF(mainFile, overviewFiles);\n}\n\n/**\n * Main creating function for GeoTIFF files.\n * @param {(Array)} array of pixel values\n * @returns {metadata} metadata\n */\nexport async function writeArrayBuffer(values, metadata) {\n  return writeGeotiff(values, metadata);\n}\n\nexport { Pool };\n"]},"metadata":{},"sourceType":"module"}